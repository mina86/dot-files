#!/usr/bin/perl

use strict;
use warnings;

use Cwd;
use IPC::Run;


my $_devnull;

sub devnull(@) {
	if (!$_devnull) {
		open($_devnull, '+<', '/dev/null') or die "e: /dev/null: $!\n";
	}
	$_devnull;
}

sub client(@) {
	my ($out, $err);
	if (@_ && $_[0] eq '-q') {
		shift @_;
		$out = devnull;
	}
	if (@_ && $_[0] eq '-Q') {
		shift @_;
		$err = devnull;
	}

	IPC::Run::run ['emacsclient', @_], \undef, $out, $err;
}


sub has_x() {
	defined $ENV{'DISPLAY'};
}


my ($windmove, $stdin) = ('', 0);

for ($_ = 0; $_ < @ARGV; ) {
	my $arg = $ARGV[$_];
	if ($arg eq '-l') {
		$windmove = 'left';
	} elsif ($arg eq '-r') {
		$windmove = 'right';
	} elsif ($arg eq '-o') {
		$windmove = 'other';
	} elsif ($arg eq '--') {
		last;
	} elsif ($arg eq '-') {
		$stdin = 1;
	} elsif ($arg =~ /^-./) {
		die "e: unknown option: $arg\n";
	} else {
		++$_;
		next;
	}
	splice @ARGV, $_, 1;
}

if ($windmove eq 'other') {
	$windmove = <<ELISP
(condition-case nil
    (windmove-right)
  (error (windmove-left)))
ELISP
} elsif ($windmove) {
	$windmove = "(condition-case nil (windmove-$windmove) (error nil))";
}


if ($stdin) {
	if (@ARGV) {
		die "e: reading standard input is supported if there are no other arguments\n";
	}

	my $data;
	$data = join '', <STDIN>;
	$data =~ s/\\/\\\\/g;
	$data =~ s/"/\\"/g;
	$data = <<ELISP;
(let ((buf (generate-new-buffer "*pipe*")))
  (set-buffer buf)
  (insert "$data")
  (goto-char (point-min))
  $windmove
  (switch-to-buffer buf)
  (x-focus-frame nil))
ELISP
	@ARGV = ('-e', $data);
	undef $windmove;
} elsif (!@ARGV) {
	@ARGV = ('-a', '');
	if (has_x) {
		push @ARGV, '-c', '-n';
	}
	exit client(@ARGV) ? 0 : 1;
}


if ($windmove) {
	client '-q', '-n', '-e', $windmove;
}

my @args = ('-a', '', has_x ? '-n' : '-t');
if ($stdin) {
	unshift @args, '-q';
}
exit client(@args, @ARGV) ? 0 : 1;
