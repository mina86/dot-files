#!/usr/bin/perl

use strict;
use warnings;

use Cwd;


sub check_exit_status($) {
	my ($cmd) = @_;
	if ($? & 127) {
		die $cmd . ': terminated with signal ' . ($? & 127) . "\n";
	} elsif ($? >> 8) {
		die $cmd . ': returned ' . ($? >> 8) . "\n";
	}
}

sub client(@) {
	# I’ve been having problems with IPC::Run and couldn’t debug them.
	# Implementing system run with proper stdin and stdout redirection
	# turned out to be the fastest solution.

	my $pid = fork();
	if (!defined $pid) {
		die "fork: $!\n";
	} elsif (!$pid) {
		open(STDIN, '<', '/dev/null') or die "/dev/null: $!\n";
		if ($_[0] eq '-q') {
			shift @_;
			open(STDOUT, '>', '/dev/null') or die "/dev/null: $!\n";
		}
		exec 'emacsclient', @_;
		die "emacsclient: $!\n";
	} elsif (waitpid($pid, 0) < 0) {
		die "wait: $!";
	} else {
		check_exit_status 'emacsclient';
	}
}


sub has_x() {
	defined $ENV{'DISPLAY'};
}


my ($windmove, $stdin) = ('', 0);

for ($_ = 0; $_ < @ARGV; ) {
	my $arg = $ARGV[$_];
	if ($arg eq '-l') {
		$windmove = 'left';
	} elsif ($arg eq '-r') {
		$windmove = 'right';
	} elsif ($arg eq '-o') {
		$windmove = 'other';
	} elsif ($arg eq '--') {
		last;
	} elsif ($arg eq '-') {
		$stdin = 1;
	} elsif ($arg =~ /^-./) {
		die "e: unknown option: $arg\n";
	} else {
		# When showing diffs, git will use ‘a/’ and ‘b/’ prefixes for
		# old and new versions of the file.  Try to detect that and
		# strip the prefix.  Similarly, if path ends with ‘:’ that might
		# be result of grep including the colon in the name; strip the
		# suffix as well.
		if (-e $arg) {
			# nop
		} elsif ($arg =~ m~^[ab]/(.+)$~ && -e $1) {
			$ARGV[$_] = $1;
		} elsif ($arg =~ m/^(.+):$/ && -e $1) {
			$ARGV[$_] = $1;
		}
		++$_;
		next;
	}
	splice @ARGV, $_, 1;
}

if ($windmove eq 'other') {
	$windmove = <<ELISP
(condition-case nil
    (windmove-right)
  (error (windmove-left)))
ELISP
} elsif ($windmove) {
	$windmove = "(condition-case nil (windmove-$windmove) (error nil))";
}


if ($stdin) {
	if (@ARGV) {
		die "e: reading standard input is supported if there are no other arguments\n";
	}

	my $data;
	$data = join '', <STDIN>;
	$data =~ s/\\/\\\\/g;
	$data =~ s/"/\\"/g;
	$data = <<ELISP;
(let ((buf (generate-new-buffer "*pipe*")))
  (set-buffer buf)
  (insert "$data")
  (goto-char (point-min))
  $windmove
  (switch-to-buffer buf)
  (x-focus-frame nil))
ELISP
	@ARGV = ('-e', $data);
	undef $windmove;
} elsif (!@ARGV) {
	client has_x ? '-cna' : '-a', '';
	exit 0;
}


if ($windmove) {
	client '-q', '-ne', $windmove;
}

my @q = $stdin ? ('-q') : ();
client @q, has_x ? '-na' : '-ta', '', @ARGV;
