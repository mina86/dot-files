;;                           -*- mode: emacs-lisp; indent-tabs-mode: nil -*-
;; .emacs  -- EMACS configuration file
;; Copyright 2004-2006 by Michal Nazarewicz (mina86@mina86.com)
;; $Id: dot-emacs,v 1.6 2006/09/23 23:15:29 mina86 Exp $
;;
;;{{{ System dependend data and directories

;; Gnus
(setq gnus-home-directory (expand-file-name "~/.gnus"))
(when (file-directory-p gnus-home-directory)
  (setq load-path (cons (concat gnus-home-directory "/gnus/lisp") load-path))
  (setq message-directory (concat gnus-home-directory "/Mail"))

  (eval-after-load "info"
    '(if (load "gnus-load")
         (setq Info-default-directory-list
               (cons (concat gnus-home-directory "/gnus/texi")
                     Info-default-directory-list)))))


;; Add  ~/elisp  to load path
(if (file-directory-p (expand-file-name "~/elisp"))
    (setq load-path (cons (expand-file-name "~/elisp") load-path)))

;; Use  aspell
(setq-default ispell-program-name "aspell")

;;}}}
;;{{{ Auto-byte-compile

(require 'bytecomp)

(defvar auto-byte-compile-files-list
  (let ((ghd (or (and (boundp 'gnus-home-directory) gnus-home-directory)
                 (expand-file-name "~"))))
    (cond
     ((string-match "\\.elc$" user-init-file)
      (list (substring user-init-file 0 -4)
            (substring user-init-file 0 -1)
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))
     (t
      (list user-init-file
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))))
  "List of files to auto compile")

(defun auto-byte-compile-file (&optional file match regexp)
  "file can be
- nil in which case value returned by `buffer-file-name' will be used
  unless it returns nil in which case no action will be taken;
- a string which is equivalent to passing list with that string as the
  only element;
- a list of strings representing file names; or
- anything else which is equivalent to passing
  `auto-byte-compile-files-list'.

Entries equal to \".\", \"..\" or ending with \"/.\" or \"/..\"
are ignored.  If element is a directory it will be processed
recursively but if regexp is nil only files ending with \".el\"
will be processed.

match can be
- nil which is equivalent to passing `auto-byte-compile-files-list';
- a string which is equivalent to passing list with that string as the
  only element;
- a list in which case file have to be in that list to be processed; or
- anything else in which case file will be processed regardless of name.

If any element of match is a string ending with a slash ('/') it
is treated as directory name (no checking is done if it is really
a directory or even if it exists) and file is sad to match such
entry if it begins with it thus all files in given directory will
match.

If called interacivelly without prefix arg will behave as with
match equal t.  With prefix arg will behave as with match equal
nil.

regexp must be nil which is equivalent with passing a list
containing only empty string or a list of regular expressions
which file have to match to be processed.

So the default is to auto-compile the current file iff it exists
in `auto-byte-compile-files-list'.

Non-string elements in list will be ignored.

Auto-compilation means that file will be byte-compiled iff the
compiled version does not exits or is older then the file
itself."
  (interactive (list (read-file-name "Auto byte compile file:" nil nil t)
                     (not current-prefix-arg)))

  (if (not (or file (setq file (buffer-file-name))))
      0
    (setq file  (cond ((stringp file)  (list file))
                      ((listp   file)  file)
                      (t               auto-byte-compile-files-list))
          match (mapcar (function (lambda (i) (expand-file-name i)))
                        (cond ((not match)     auto-byte-compile-files-list)
                              ((stringp match) (list match))
                              ((listp match)   match)
                              (t               nil))))

    (let (f (n 0))
      (while (setq f (car file))
        (setq file (cdr file) f (expand-file-name f))
        (cond
         ((string-match f "\\(^\\|/\\)\\.\\.?$"))
         ((file-directory-p f)
          (if regexp
              (setq file (append (directory-files f t nil t) file))
            (setq n (+ n (auto-byte-compile-file (directory-files f t nil t)
                                                 (or match t) '("\\.el$"))))))
         ((and (file-newer-than-file-p f (byte-compile-dest-file f))
               (or (not match)
                   (catch 'found
                     (dolist (m match)
                       (if (string= m (if (string-match "/$" m)
                                          (substring f 0 (length m)) f))
                           (throw 'found t)))))
               (or (not regexp)
                   (catch 'found (dolist (r regexp)
                                   (if (string-match r f) (throw 'found t)))))
               (byte-compile-file f)
               (setq n (1+ n))))))
      n)))

(defun auto-byte-compile-buffer (&optional match buffer)
  "Auto compiles file in given buffer (if buffer is nil current
buffer is used) providing that major mode of the buffer is
lisp-mode or emacs-lisp-mode.  match has the same meaning as in
`auto-byte-compile-file'.

If called interacivelly will behave as with match equal t and
buffer equal nil unless prefix argument was given in which case
match will equal nil."
  (interactive (list (not current-prefix-arg) nil))
  (and (buffer-file-name buffer)
       (member (if buffer (save-current-buffer (set-buffer buffer)
                                               major-mode) major-mode)
               '(lisp-mode emacs-lisp-mode))
       (auto-byte-compile-file (buffer-file-name buffer) match)))


(add-hook 'kill-buffer-hook 'auto-byte-compile-buffer)
(add-hook 'kill-emacs-hook (function (lambda () (auto-byte-compile-file t))))

;;}}}
;;{{{ Bindings

(defmacro set-key-lambda (key &rest body)
  `(global-set-key ,key (function (lambda () (interactive) ,@body))))

;;{{{ Sequence commands

;; Sequence commands  1.2  by me, Michal Nazarewicz ;)
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
(defvar seq-store-times 0)
(defvar seq-start-point 0
  "Stores location of pointer when sequence of calls of the same
function was started. This variable is updated by `seq-times'")
(defvar seq-start-window-start 0
  "Stores location at which display started in window when
sequence of calls of the same function was started. This variable
is updated by `seq-times'")

(defun seq-times (&optional name max)
  "Returns number of times command `name' was executed. If `name'
is an empty string won't check if `last-command' matches. If
`max' is specified the counter will wrap around at the value of
`max' never reaching it. It also updates `seq-start-point'."
  (if (numberp name) (setq max name name this-command)
    (unless name (setq name this-command)))
  (if (or (equal "" name) (equal last-command name))
      (if (eq (setq seq-store-times (1+ seq-store-times)) max)
          (setq seq-store-times 0) seq-store-times)
    (setq seq-start-point (point) seq-start-window-start (window-start)
          seq-store-times 0)))

;;}}}
;;{{{ Home/End

;; My home
(defun my-home ()
   "Depending on how many times it was called moves the point to:
once - beginning of line; twice - indent;
three times - beginning of buffer; four times - back to where it was."
   (interactive)
   (let ((n (seq-times 4)))
     (cond ((= n 0) (beginning-of-line))
           ((= n 1) (back-to-indentation))
           ((= n 2) (goto-char (point-min)))
           (t (goto-char seq-start-point)))))

(global-set-key "\C-a"          'my-home)
(global-set-key [home]          'my-home)
(global-set-key [kp-home]       'my-home)
(global-set-key [f27]           'my-home)
(global-set-key "\e[1~"         'my-home)


;; My end
(defun my-end () "Go to end of line or buffer" (interactive)
  (let ((n (seq-times 4)))
    (cond ((= n 0) (end-of-line))
          ((= n 1) (forward-paragraph))
          ((= n 2) (goto-char (point-max)))
          (t (goto-char seq-start-point)))))

(global-set-key "\C-e"          'my-end)
(global-set-key [end]           'my-end)
(global-set-key [kp-end]        'my-end)
(global-set-key [select]        'my-end)
(global-set-key [f33]           'my-end)
(global-set-key "\e[4~"         'my-end)

;;}}}
;;{{{ Pager/Scrolling

;; Makes paging functions work the way god intended
;; http://www.docs.uu.se/~mic/emacs.html
;; pager.el was modified by my
(require 'pager)
(setq pager-goto-edge t)

(global-set-key "\ev"           'pager-page-up)     ; Page Up
(global-set-key [prior]         'pager-page-up)
(global-set-key [f29]           'pager-page-up)
(global-set-key "\C-v"          'pager-page-down)   ; Page Down
(global-set-key [next]          'pager-page-down)
(global-set-key [f35]           'pager-page-down)

(set-key-lambda '[M-up]         (scroll-down 1))    ; Alt+Up
(set-key-lambda '[M-kp-8]       (scroll-down 1))
(set-key-lambda "\M-p"          (scroll-down 1))
(set-key-lambda '[M-down]       (scroll-up   1))    ; Alt+Dn
(set-key-lambda '[M-kp-2]       (scroll-up   1))
(set-key-lambda "\M-n"          (scroll-up   1))

(global-set-key '[M-S-up]       'pager-row-up)      ; Alt+Shift+Up
(global-set-key '[M-S-kp-8]     'pager-row-up)
(global-set-key "\M-P"          'pager-row-up)
(global-set-key '[M-S-down]     'pager-row-down)    ; Alt+Shift+Down
(global-set-key '[M-S-kp-2]     'pager-row-down)
(global-set-key "\M-N"          'pager-row-down)

;;}}}
;;{{{ Save with no blanks

;; Save with no trailing whitespaces
(defun save-no-blanks (&optional arg) (interactive "P")
  (save-excursion
    (goto-char 0) (perform-replace "[ \t]+$" "" nil t nil)
    (goto-char (point-max)) (delete-blank-lines)
    (save-buffer arg)))

(global-set-key "\C-x\C-s"      'save-no-blanks)        ; C-x C-s  no blanks
(global-set-key "\C-xS"         'save-buffer)           ; C-x S    normal

;;}}}
;;{{{ Misc

(unless window-system
  (global-set-key "\C-h"          'delete-backward-char))
(global-set-key [backspace]     'delete-backward-char)
(global-set-key [delete]        'delete-char)

(global-set-key "\C-xg"         'goto-line)             ; C-x g  goto line
(global-set-key "\C-xp"         "\C-u-1\C-xo")          ; C-x p  prev win
(global-set-key "\C-xk"         'kill-this-buffer)      ; don't ask which
                                                        ; buffer to kill
(global-set-key "\C-cr"         'revert-buffer)         ; Reload buffer
(set-key-lambda "\C-x\C-b" (switch-to-buffer (other-buffer))) ; C-x C-b switch

;(autotoload 'goto-last-change "goto-last-change"
;  "Set point to the position of the last change." t)
;(global-set-key "\C-x\C-\\" 'goto-last-change)

(require 'imenu)
(global-set-key [S-mouse-3]     'imenu)
(setq imenu-sort-function 'imenu--sort-by-name)

;; Mouse gestures (a.k.a. strokes)
;(strokes-mode 1)
;(global-set-key [down-mouse-3]  'strokes-do-stroke)


;; Centering
(defun centerer ()
   "Repositions current line: once - middle, twice - top, three
and four times - `reposition-window', five times - bottom, six
times - where it was at the beginning."
   (interactive)
   (let (n (i 0) (old (window-start)))
     (while (and (< i 6) (equal (window-start) old))
       (setq i (1+ i) n (seq-times "" 6))
       (cond ((= n 0) (recenter))
             ((= n 1) (recenter 0))
             ((< n 4) (reposition-window))
             ((= n 4) (recenter -1))
             (t (set-window-start (selected-window) seq-start-window-start)))
       )))

(global-set-key "\C-l"     'centerer)


;; Tab - indent or complete
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar indent-or-complete-complete-function 'dabbrev-expand
  "Function to complete the word when using `indent-or-complete'
It is called with one argument - nil")

(defvar indent-or-complete--last-was-complete nil)

(defun indent-or-complete ()
  "Complete if point is at end of a word, otherwise indent line.
Uses `indent-or-complete-complete-function' function when completing
and `indent-for-tab-command' when indenting"
  (interactive)
  (if (set 'indent-or-complete--last-was-complete
           (or (looking-at "\\>")
               (and (eq last-command this-command)
                    indent-or-complete--last-was-complete)))
      (funcall indent-or-complete-complete-function nil)
    (indent-for-tab-command)))

(add-hook 'find-file-hooks (function (lambda ()
  (local-set-key (kbd "<tab>") 'indent-or-complete))))
(save-current-buffer
  (set-buffer "*scratch*")
  (local-set-key (kbd "<tab>") 'indent-or-complete))


;; Alt+q - Filling
(defun fill-paragraph-or-region (&optional arg)
  "Runs `fill-region' if `mark-active', `fill-paragraph' otherwise."
  (interactive (progn (barf-if-buffer-read-only)
                      (list (if current-prefix-arg 'full))))
  (if mark-active
      (fill-region (region-beginning) (region-end) arg) (fill-paragraph arg)))

(defun my-fill () "" (interactive)
   (fill-paragraph-or-region (nth (seq-times 4) '(left full right center))))

(global-set-key "\M-q"          'my-fill)


;; Do not break line after single character when filling
(defun fill-single-char-nobreak-p ()
  "Don't break line after a single character."
  (save-excursion
    (skip-chars-backward " \t") (backward-char 2)
    (looking-at "[[:space:]]][a-zA-Z]")))

(add-to-list 'fill-nobreak-predicate 'fill-single-char-nobreak-p)

;; Do not break at '\ '
; not tested
(defun fill-nroff-slash-space-nobreak-p ()
  "Don't break line after a '\ ' sequence if in `nroff-mode'."
  (and (equal major-mode 'nroff-mode)
       (save-excursion (backward-char 2) (looking-at "\\\\ \\|.\\\\"))))

(add-to-list 'fill-nobreak-predicate 'fill-nroff-slash-space-nobreak-p)


;; Jump
(require 'ffap)
(defun my-jump () "Jump to the thing at point." (interactive)
  (let ((thing (ffap-guesser))) (if thing (ffap thing)) t))

(global-set-key [C-return] 'my-jump)
(global-set-key [C-S-mouse-3] 'ffap-at-mouse)


;; Make l behave as it should in help-mode
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(add-hook 'help-mode-hook
          (function (lambda () (define-key help-mode-map "l" 'help-go-back))))

;;}}}
;;{{{ Fkeys

;;{{{ Key sequences

(global-set-key "\eOP"       [f1])
(global-set-key "\e[[A"      [f1])
(global-set-key "\eOQ"       [f2])
(global-set-key "\e[[B"      [f2])
(global-set-key "\eOR"       [f3])
(global-set-key "\e[[C"      [f3])
(global-set-key "\eOS"       [f4])
(global-set-key "\e[[D"      [f4])
(global-set-key "\e[15~"     [f5])
(global-set-key "\e[[E"      [f5])
(global-set-key "\e[17~"     [f6])
(global-set-key "\e[18~"     [f7])
(global-set-key "\e[19~"     [f8])
(global-set-key "\e[20~"     [f9])
(global-set-key "\e[21~"     [f10])
(global-set-key "\e[23~"     [f11])
(global-set-key "\e[24~"     [f12])
(global-set-key "\eO5P"      [C-f1])
(global-set-key "\eO5Q"      [C-f2])
(global-set-key "\eO5R"      [C-f3])
(global-set-key "\eO5S"      [C-f4])
(global-set-key "\e[15;5~"   [C-f5])
(global-set-key "\e[17;5~"   [C-f6])
(global-set-key "\e[18;5~"   [C-f7])
(global-set-key "\e[19;5~"   [C-f8])
(global-set-key "\e[20;5~"   [C-f9])
(global-set-key "\e[21;5~"   [C-f10])
(global-set-key "\e[23;5~"   [C-f11])
(global-set-key "\e[24;5~"   [C-f12])
(global-set-key "\eO6P"      [C-S-f1])
(global-set-key "\eO6Q"      [C-S-f2])
(global-set-key "\eO6R"      [C-S-f3])
(global-set-key "\eO6S"      [C-S-f4])
(global-set-key "\e[15;6~"   [C-S-f5])
(global-set-key "\e[17;6~"   [C-S-f6])
(global-set-key "\e[18;6~"   [C-S-f7])
(global-set-key "\e[19;6~"   [C-S-f8])
(global-set-key "\e[20;6~"   [C-S-f9])
(global-set-key "\e[21;6~"   [C-S-f10])
(global-set-key "\e[23;6~"   [C-S-f11])
(global-set-key "\e[24;6~"   [C-S-f12])
(global-set-key "\eO3P"      [M-f1])
(global-set-key "\eO3Q"      [M-f2])
(global-set-key "\eO3R"      [M-f3])
(global-set-key "\eO3S"      [M-f4])
(global-set-key "\e[15;3~"   [M-f5])
(global-set-key "\e[17;3~"   [M-f6])
(global-set-key "\e[18;3~"   [M-f7])
(global-set-key "\e[19;3~"   [M-f8])
(global-set-key "\e[20;3~"   [M-f9])
(global-set-key "\e[21;3~"   [M-f10])
(global-set-key "\e[23;3~"   [M-f11])
(global-set-key "\e[24;3~"   [M-f12])
(global-set-key "\eO4P"      [M-S-f1])
(global-set-key "\eO4Q"      [M-S-f2])
(global-set-key "\eO4R"      [M-S-f3])
(global-set-key "\eO4S"      [M-S-f4])
(global-set-key "\e[15;4~"   [M-S-f5])
(global-set-key "\e[17;4~"   [M-S-f6])
(global-set-key "\e[18;4~"   [M-S-f7])
(global-set-key "\e[19;4~"   [M-S-f8])
(global-set-key "\e[20;4~"   [M-S-f9])
(global-set-key "\e[21;4~"   [M-S-f10])
(global-set-key "\e[23;4~"   [M-S-f11])
(global-set-key "\e[24;4~"   [M-S-f12])
(global-set-key "\eO2P"      [S-f1])
(global-set-key "\e[23~"     [S-f1])
(global-set-key "\eO2Q"      [S-f2])
(global-set-key "\e[24~"     [S-f2])
(global-set-key "\eO2R"      [S-f3])
(global-set-key "\e[25~"     [S-f3])
(global-set-key "\eO2S"      [S-f4])
(global-set-key "\e[26~"     [S-f4])
(global-set-key "\e[15;2~"   [S-f5])
(global-set-key "\e[28~"     [S-f5])
(global-set-key "\e[17;2~"   [S-f6])
(global-set-key "\e[29~"     [S-f6])
(global-set-key "\e[18;2~"   [S-f7])
(global-set-key "\e[31~"     [S-f7])
(global-set-key "\e[19;2~"   [S-f8])
(global-set-key "\e[32~"     [S-f8])
(global-set-key "\e[20;2~"   [S-f9])
(global-set-key "\e[33~"     [S-f9])
(global-set-key "\e[21;2~"   [S-f10])
(global-set-key "\e[34~"     [S-f10])
(global-set-key "\e[23;2~"   [S-f11])
(global-set-key "\e[24;2~"   [S-f12])

;;}}}
;;{{{ F1 - Help

(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
   (let ((fn (function-called-at-point)))
     (if fn
         (describe-function fn)
       (manual-entry (current-word)))))

(global-set-key [f1]        'my-help)

;;}}}
;;{{{ F2 - find configuration file s

(defmacro mn-kbd-find-file (file)
  `(function (lambda () (interactive) (find-file ,file))))

(global-set-key [f2]        (mn-kbd-find-file "~/.emacs"))
(global-set-key [C-f2]      (mn-kbd-find-file "~/.gnus/.gnus.el"))
(global-set-key [M-f2]      (mn-kbd-find-file "~/.emacs.custom"))
(global-set-key [S-f2]      (mn-kbd-find-file "~/.bashrc"))

;;}}}
;;{{{ F5 - Gnus

;; http://www.emacswiki.org/cgi-bin/wiki/SwitchToGnus
(defun switch-to-gnus-or-get-new-news (&optional arg)
  "If already in Gnus group retrive new news otherwise, if Gnus
is running, switch to Gnus group buffer, otherwise start gnus"
  (interactive "p")
  (cond
   ((string= (buffer-name) "*Group*") (gnus-group-get-new-news arg))
   ((and (fboundp 'gnus-alive-p) (gnus-alive-p)) (switch-to-buffer "*Group*"))
   (t (gnus))))

(global-set-key [f5]        'switch-to-gnus-or-get-new-news)

;;}}}
;;{{{ F7 - spell checking

(require 'ispell)

;;{{{ ispell-change-dictionary bugfix

(defun ispell-change-dictionary (dict &optional arg)
  "Change to dictionary DICT for Ispell.
With a prefix arg, set it \"globally\", for all buffers.
Without a prefix arg, set it \"locally\", just for this buffer.

By just answering RET you can find out what the current dictionary is."
  (interactive
   (list (completing-read
          "Use new dictionary (RET for current, SPC to complete): "
          (and (fboundp 'ispell-valid-dictionary-list)
               (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)
         current-prefix-arg))
  (unless arg (ispell-buffer-local-dict 'no-reload))
  (if (equal dict "default") (setq dict nil))
  ;; This relies on completing-read's bug of returning "" for no match
  (cond
   ((equal dict "")
    (ispell-internal-change-dictionary)
    (message "Using %s dictionary"
             (or (and (not arg) ispell-local-dictionary)
                 ispell-dictionary "default")))
   ((equal dict (or (and (not arg) ispell-local-dictionary)
                    ispell-dictionary "default"))
    ;; Specified dictionary is the default already. Could reload
    ;; the dictionaries if needed.
    (ispell-internal-change-dictionary)
    (if (interactive-p) (message "No change, using %s dictionary" dict)))
   (t ; reset dictionary!
    (if (or (assoc dict ispell-local-dictionary-alist)
            (assoc dict ispell-dictionary-alist))
        (if arg
            ;; set default dictionary
            (setq ispell-dictionary dict)
          ;; set local dictionary
          (setq ispell-local-dictionary dict)
          (setq ispell-local-dictionary-overridden t))
      (error "Undefined dictionary: %s" dict))
    (ispell-internal-change-dictionary)
    (message "%s Ispell dictionary set to %s"
             (if arg "Global" "Local")
             dict))))

;;}}}

(defvar mn-spell-dictionaries '("polish" "british")
  "List of dictionaries to cycle through with `mn-spell-switch-dictionary'.")

(eval-after-load "ispell"
  (ispell-change-dictionary "polish" t))

(defun mn-spell (&optional lang start end)
  "If LANG is not-nil sets ispell dictionary to lang, then checks
region from START to END for spelling errors.  The default values
for START and END are `region-beginning' and `region-end' if
`transient-mark-mode' is on and `mark-active' or `point-min' and
`point-max' otherwise.

However, if START is nil, END is not and `region-beginning' falls
after END START will get value of `point-min'.  And the other way
around: if END is nil, START is not and `region-end' falls before
START END will get value of `point-max'.

If LANG is an empty string local dictionary is set to
nil (ie. the global dictionary is used).

If START >= END this function only sets the dictionary and
returns nil.  Otherwise it returns whatever `ispell-region'
returned."
  (interactive
   (list (completing-read
          "Use new dictionary (RET for current, SPC to complete): "
          (and (fboundp 'ispell-valid-dictionary-list)
               (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)))
  (if lang (ispell-change-dictionary (if (string= lang "") nil lang)))
  (cond
   ((not (and (boundp 'transient-mark-mode) transient-mark-mode
              (boundp 'mark-active) mark-active))
    (if (not start) (setq start (point-min)))
    (if (not end)   (setq end   (point-max))))
   ((not (or start end))
    (let ((s (region-beginning)) (e (region-end)))
      (if (and end   (>= s end  )) (setq s (point-min)))
      (if (and start (<= e start)) (setq e (point-max))))))
  (if (< start end) (ispell-region start end)))

(defun mn-spell-switch-dictionary (&optional arg)
  "Switches dictionary to the next dictionary from `mn-spell-dictionaries'.
With a prefix arg sets global dictionary."
  (interactive "P")
  (ispell-change-dictionary
   (let ((dic (or (and (not arg) ispell-local-dictionary) ispell-dictionary))
         (list mn-spell-dictionaries))
     (while (and list (not (string= (car list) dic))) (setq list (cdr list)))
     (setq dic (or (car list) (car mn-spell-dictionaries)))
     (message "%s" dic)
     dic
   arg)))


(set-key-lambda [f7]        (mn-spell))
(set-key-lambda [C-f7]      (mn-spell nil (point)))

(global-set-key [M-f7]      'mn-spell-switch-dictionary)

;;}}}
;;{{{ F8 - Keyboard macros

(global-set-key [f8]        'kmacro-end-or-call-macro)
(global-set-key [C-f8]      'kmacro-start-macro-or-insert-counter)

;;}}}
;;{{{ F9 - Compilation

(defvar mn-compile-vars
  '((("CFLAGS"   "-Wall -pedantic -std=c99   -Wextra -Wfloat-equal -Wshadow -Wpadded -Wunreachable-code -Winline -ggdb -O0")
     ("CXXFLAGS" "-Wall -pedantic -std=c++98 -Wextra -Wfloat-equal -Wshadow -Wpadded -Wunreachable-code -Winline -ggdb -O0")
     ("CPPFLAGS" "-Wall -pedantic -std=c99")
     ("LDFLAGS"  nil))

    (("CFLAGS"   "-Wall -pedantic -std=c89   -Wextra -Wfloat-equal -Wshadow -Wpadded -Wunreachable-code -Winline -ggdb -O0")
     ("CXXFLAGS" "-Wall -pedantic -std=c++98 -Wextra -Wfloat-equal -Wshadow -Wpadded -Wunreachable-code -Winline -ggdb -O0")
     ("CPPFLAGS" "-Wall -pedantic -std=c89")
     ("LDFLAGS"  nil)))

  "List of enviroment variables set by `mn-compile' priory to
compilation.  The car of the list is a list of default enviroment
variables to be set and cadr is a list is a list of alternative
enviroment variables.  Each list is a list of two element lists
which car is a enviroment variables name and cadr is value.")


(defun mn-compile (&optional alt recompile touch)
  "If alt is omited or nil sets CFLAGS, CXXFLAGS, CPPFLAGS and
LDFLAGS enviroment variables to `mn-cflags', `mn-cxxflags',
`mn-cppflags', `mn-ldflags' respectively.

If alt is non-nil (or when called interactive with any prefix
argument) sets CFLAGS, CXXFLAGS, CPPFLAGS and LDFLAGS enviroment
variables to `mn-alt-cflags', `mn-alt-cxxflags',
`mn-alt-cppflags', `mn-alt-ldflags' respectively.

Afterwards, if touch is non-nil marks buffer as modified.  Saves
buffer (`save-buffer') and executes `recompile' if recompile is
non-nill or `compile' otherwise."

  (interactive "P")
  (if touch (set-buffer-modified-p t))
  (save-buffer)
  (if (or (equal major-mode 'lisp-mode) (equal major-mode 'emacs-lisp-mode))
      (auto-byte-compile-file nil t)
    (let (v (vars (if alt (cadr mn-compile-vars) (car mn-compile-vars))))
      (while (set 'v (pop vars)) (setenv (car v) (cadr v))))
    (if recompile (recompile) (call-interactively 'compile))))


(global-set-key [f9]        'mn-compile)               ; F9    compile
(global-set-key [C-f9]                                 ; C-F9  recompile
                (function (lambda (a) (interactive "P") (mn-compile a t))))
(global-set-key [M-f9]                                 ; M-F9  force alt comp.
                (function (lambda (a) (interactive "P") (mn-compile (not a) t t))))

;;}}}

;;}}}
;;{{{ ISearch mode

(add-hook 'isearch-mode-hook (lambda ()
 (define-key isearch-mode-map "\C-h"      'isearch-mode-help)
 (define-key isearch-mode-map "\C-t"      'isearch-toggle-regexp)
 (define-key isearch-mode-map "\C-c"      'isearch-toggle-case-fold)
 (define-key isearch-mode-map "\C-j"      'isearch-edit-string)
; (define-key isearch-mode-map "\C-h"      'isearch-del-char)
 (define-key isearch-mode-map [backspace] 'isearch-del-char)
))

;;}}}
;;{{{ RISC mode

(autoload 'risc-mode        "risc-mode" "Toggles RISC Mode on or off" t)
(autoload 'risc-mode-toggle "risc-mode" "Toggles RISC Mode on or off" t)
(global-set-key "\C-c\C-c"     'risc-mode-toggle)
(global-set-key (kbd "<menu>") 'risc-mode-toggle)

;;}}}

;;}}}
;;{{{ Syntax highlighting

;;{{{ Font lock

(require 'font-lock)
(global-font-lock-mode t)
(setq font-lock-verbose nil)          ;no messages

;; Let customize keep config there
(setq custom-file (expand-file-name "~/.emacs.custom"))
(if (file-exists-p custom-file) (load-file custom-file))
(if (boundp 'auto-byte-compile-files-list)
    (setq auto-byte-compile-files-list
          (cons custom-file auto-byte-compile-files-list)))

;;}}}
;;{{{ Lazy lock

;; Makes everything work faster with big files
;(require 'lazy-lock)
;(setq font-lock-support-mode 'lazy-lock-mode)
;(setq lazy-lock-minimum-size 16384)   ;use lazy lock only with file >16KB
;(setq lazy-lock-defer-on-scrolling t) ;delay fontyfing on scrolling
;(setq lazy-lock-defer-time 1)         ;must be 1s idle to refontify
;(setq lazy-lock-stealth-time 16)      ;fontfy in advance if 20s idle
;(setq lazy-lock-stealth-lines 64)     ;fontify 50 lines when idle
;(setq lazy-lock-stealth-verbose nil)  ;not verbouse

;;}}}
;;{{{ Other

(setq query-replace-highlight t)  ;highlight during query
(setq search-highlight t)         ;highlight incremental search
(show-paren-mode t)               ;show matching parenthesis.

;;}}}
;;{{{ Show blanks and FIXME

;; http://www.emacswiki.org/cgi-bin/wiki/EightyColumnRule

(custom-set-faces
 '(my-tab-face ((((class color))
   (:background "#555" :foreground "black" :underline t))) t)
 '(my-big-indent-face ((((class color))
   (:background "#755" :foreground "black" :underline t))) t)
 '(my-huge-indent-face ((((class color))
   (:background "#C55" :foreground "black" :underline t))) t)
 '(my-fixme-face ((((class color))
   (:background "red" :foreground "white" :weight bold))) t)
 )


(add-hook 'font-lock-mode-hook (function (lambda ()
  (unless (or (eq 'diff-mode major-mode) (eq 'script-mode major-mode))
    (font-lock-add-keywords nil
     '(("\t+" 0 'my-tab-face t)
       ("\t\\{4,\\}" 0 'my-big-indent-face t)
       ("\t\\{6,\\}" 0 'my-huge-indent-face t)
       ("!\\{3\\}IMPORTANT!!!.*!!!" 0 'my-fixme-face t)
       ("\\<\\(FIXME:\\)" 1 'my-fixme-face t)))))))

;;}}}

;;}}}
;;{{{ Misc small config

;;Save some space
(menu-bar-mode -1)                ;no menu bar
(when window-system
  (tool-bar-mode -1)              ;no tool bar
  (scroll-bar-mode -1)            ;no scroll bar
  (require 'fringe)
  (set-fringe-mode '(2 . 4)))     ;small fringe

;; Modeline, Minibuffer & Frame title
(setq line-number-mode t)         ;show line number in modeline
(setq column-number-mode nil)     ;don't show column number in modeline
(resize-minibuffer-mode nil)      ;dont resize minibuffer      (doesn't work?)
(setq suggest-key-bindings 3)     ;suggestions for shortcut keys for 3 seconds
(setq frame-title-format "%b - Emacs") ;frame title format

;; Other
(setq inhibit-startup-message t)  ;don't show splash screen
(setq inhibit-startup-buffer-menu t) ;don't show buffer menu when oppening
                                  ; many files               (EMACS 21.4+)
(setq sentence-end-double-space 1);sentance end with double space
(setq truncate-lines nil)         ;wrap lines
(fset 'yes-or-no-p 'y-or-n-p)     ;make yes/no be y/n
(setq require-final-newline t)    ;always end file with NL
(setq x-alt-keysym 'meta)         ;treat Alt as Meta even if real Meta found
(setq gc-cons-threshold 4000000)  ;bytes before garbage collection
(setq ange-ftp-ftp-program-name "pftp") ;passive FTP
(blink-cursor-mode nil)           ;do not blink cursor
;(add-hook 'before-save-hook 'time-stamp) ;install time-stamp
;(setq time-stamp-active nil)      ;but disable by default

;; Saving etc
(if (fboundp recentf-mode)
    (recentf-mode nil))           ;no recent files
(auto-compression-mode 1)         ;automatic compression
(setq make-backup-files nil)      ;no backup
;(global-auto-revert-mode 1)       ;automaticly reload buffer when changed
                                  ; it makes all folds unfload :(
                                  ; and what's worse - sux with ftp

;; Indention
(defun tab-stop-list (&optional width columns)
  "Returns list of all positive integers ordered rom smallest to
largest which are multiplications of WIDTH and are lower or equal
COLUMNS.  WIDTH defaults to `tab-width' and COLUMNS to 120."
  (if (not width) (setq width tab-width))
  (when (<= width (or columns 120))
    (let* (l (n (/ (or columns 120) width )))
      (while (> (setq l (cons (* n width) l) n (1- n)) 0)) l)))

(setq indent-tabs-mode t)         ;indent using tabs
(setq c-basic-offset 4)           ;4 char indent in cc-mode
(setq tab-width 4)                ;tab width
(setq tab-stop-list (eval-when-compile (tab-stop-list 4)))
;; One could add this to check if tab-width and c-basic-offset correspond
;(if (not (= 0 (% c-basic-offset tab-width)))
;    (warn "`tab-width' does not divide `c-basic-offset'"))

;; Regions a.k.a. Selection
(setq mouse-yank-at-point t)      ;mouse yank at point not at cursor   (X-win)
(setq kill-read-only-ok t)        ;be silent when killing text from RO buffer
(delete-selection-mode 1)         ;deleting region by typing or del (like Win)
;(setq transient-mark-mode 1)      ;highlight selections

;; Scrolling/moving
(setq scroll-step 1)              ;scroll one line
;(setq scroll-preserve-screen-position t) ;keep point's position on screen
(setq hscroll-step 1)             ;scroll one column
(setq next-line-add-newlines nil) ;no new lines with down arrow key

;; Coding system
(set-keyboard-coding-system 'iso-8859-2)
(set-terminal-coding-system 'iso-8859-2)

;; Blink Scroll Lock LED instead of beep
(setq visible-bell nil)           ;no visual bell
(setq ring-bell-function (function (lambda ()
  (call-process-shell-command "xset led 3; xset -led 3" nil 0 nil))))

;; Each list element as new paragraph
;; http://www.emacswiki.org/cgi-bin/wiki/FillParagraph
(setq paragraph-start    " *\\([*+-]\\|\\([0-9]+\\|[a-zA-Z]\\)[.)]\\|$\\)"
      paragraph-separate "$")

;;}}}
;;{{{ Modes and stuff

;;{{{ CC Modes family

;; PHP mode
;; http://sourceforge.net/projects/php-mode
(autoload 'php-mode "php-mode" "PHP editing mode" t)
(add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode))

;; JavaScript mode
;; http://www.brigadoon.de/peter/javascript-mode.el
;(autoload 'javascript-mode "~/elisp/javascript-mode.elc" "JS editing mode" t)
;(add-to-list 'auto-mode-alist '("\\.js\\'" . javascript-mode))
(add-to-list 'auto-mode-alist '("\\.js\\'" . c-mode))

;; Default indenting mode
;(setq c-default-style "linux")

;; Default compile command
(eval-after-load "compile"
  (add-hook 'c-mode-hook
            (lambda ()
              (if buffer-file-name
                  (set (make-local-variable 'compile-command)
                       (let ((file (file-name-nondirectory buffer-file-name)))
                         (concat "make -k " file)))))))

;;}}}
;;{{{ CSS Mode

;; http://www.garshol.priv.no/download/software/css-mode/index.html
(autoload 'css-mode "css-mode" "CSS editing mode" t)
(setq cssm-indent-function #'cssm-c-style-indenter) ;C-style indenting in CSS
(add-to-list 'auto-mode-alist '("\\.css\\'" . css-mode))

;;}}}
;;{{{ HTML Mode

;; PSGML Mode
;(require 'psgml)

;; Insert char or entity when pressed 2 times
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
(eval-after-load "sgml-mode"
  (progn
    (defmacro rgb-insert-if-double (otherwise)
      `(function (lambda (arg) (interactive "P")
                   (if (or arg (not (equal (preceding-char) last-command-char)))
                       (self-insert-command (prefix-numeric-value arg))
                     (backward-delete-char 1)
                     (insert ,otherwise)))))

    (add-hook 'html-mode-hook (function (lambda ()
      (define-key html-mode-map [(<)]  (rgb-insert-if-double "&lt;"))
      (define-key html-mode-map [(>)]  (rgb-insert-if-double "&gt;"))
      (define-key html-mode-map [(&)]  (rgb-insert-if-double "&amp;"))
      (define-key html-mode-map [(\")] (rgb-insert-if-double "&quot;")))))))

;; Generates TOC based on <H?> elements
;; http://www.emacswiki.org/cgi-bin/wiki/HtmlToc
;(defun html-show-toc () "Shows a TOC based on headings tags <H[1-6]>"
;  (interactive)
;  (if sgml-tags-invisible (error "SGML tags are invisible")
;    (occur "<h[1-6]>")
;    (pop-to-buffer "*Occur*") (vc-toggle-read-only)
;    (goto-char (point-min)) (replace-string "<h1>" " ")
;    (goto-char (point-min)) (replace-string "<h2>" "  ")
;    (goto-char (point-min)) (replace-string "<h3>" "   ")
;    (goto-char (point-min)) (replace-string "<h4>" "    ")
;    (goto-char (point-min)) (replace-string "<h5>" "     ")
;    (goto-char (point-min)) (replace-string "<h6>" "      ")
;    (goto-char (point-min)) (replace-regexp "</h[1-6]>" "")
;    (goto-char (point-min)) (toggle-read-only 1)))

;;}}}
;;{{{ MMM Mode

;(require 'mmm-mode)
;(setq mmm-global-mode 'maybe)
;(set-face-background 'mmm-default-submode-face nil)
;
;(mmm-add-group
; 'html-php
; '((html-php-tagged :submode php-mode :front "<\\?php" :back "\\?>")))
;
;(add-to-list 'auto-mode-alist '("\\.php\\'" . html-mode))
;
;(add-to-list 'mmm-mode-ext-classes-alist '(html-mode nil html-js))
;(add-to-list 'mmm-mode-ext-classes-alist '(html-mode nil embedded-css))
;(add-to-list 'mmm-mode-ext-classes-alist '(html-mode "\\.php\\'" html-php))

;;}}}
;;{{{ Text mode

(add-hook 'text-mode-hook (function (lambda ()
    (auto-fill-mode t)
    (setq tab-width 8)
    (setq tab-stop-list
    (set (make-local-variable 'tab-stop-list)
         (eval-when-compile (tab-stop-list 8)))))))
(setq auto-mode-alist (append '(("\\.ftf\\'" . text-mode)) auto-mode-alist))

;;}}}
;;{{{ (La)TeX mode

;; Helper for tex-space
(defun my-tex-looking-back (regexp len)
  "Returns non-nil if text LEN chars backward matches REGEXP and
is at the beginning of line or preceded by white space."
  (save-excursion
    (backward-char len)
    (if (looking-at regexp)
        (or (looking-at "^")
            (progn (backward-char 1) (looking-at "[[:space:]]"))))))

;; Insert '~' or '\ ' instead of ' ' in LaTeX when needed
;; Also removes '~' when 2nd space added
;; http://www.debianusers.pl/article.php?aid=39
(defun tex-space (arg) (interactive "P")
  (cond
   ((re-search-backward "\\~" (- (point) 1) t)
    (delete-char 1) (self-insert-command (prefix-numeric-value arg)))
   (arg (self-insert-command (prefix-numeric-value arg)))
   ((or (my-tex-looking-back "[a-z]" 1)
        (my-tex-looking-back "[a-z][a-z]" 2))
    (insert-char ?~ 1))
   ((or (my-tex-looking-back "\\(?:tj\\|np\\|ew\\|jw\\|in\\|wg\\)\\." 3)
        (my-tex-looking-back "\\(?:tzw\||tzn\\)\\." 4))
    (insert "\\ "))
   (t (self-insert-command 1))))

(eval-when-compile (require 'tex-mode))

(defun my-tex-hook () (define-key tex-mode-map " " 'tex-space))
(add-hook 'tex-mode-hook 'my-tex-hook)
(add-hook 'TeX-mode-hook 'my-tex-hook)
(add-hook 'latex-mode-hook 'my-tex-hook)
(add-hook 'LaTeX-mode-hook 'my-tex-hook)

;;}}}
;;{{{ Nroff mode

;; Insert '\ ' instead of ' ' in nroff when needed
;; Also removes '\' when 2nd space added
(defun nroff-space (arg) (interactive "p")
  (cond
   ((re-search-backward "\\\\ " (- (point) 2) t)
    (delete-char 1) (forward-char) (self-insert-command arg))
   ((> arg 1) (self-insert-command arg))
   ((or (my-tex-search-back "[a-z]" 1)
        (my-tex-search-back "[a-z][a-z]" 2))
;        (my-tex-search-back "do\\|na\\|od\\|po\\|za\\|we\\|to\\|co" 2))
    (insert-char ?\\ 1) (self-insert-command 1))
   (t (self-insert-command 1))))

(eval-when-compile (require 'nroff-mode))

(defun my-nroff-hook () (define-key nroff-mode-map " " 'nroff-space))
(add-hook 'nroff-mode-hook 'my-tex-hook)

;;}}}
;;{{{ Assembler mode

(add-hook 'asm-mode-hook (function (lambda ()
    (set-variable 'tab-width 8)
    (set-variable 'tab-stop-list
                  '(16 24 32 40 48 56 64 72 80 88 96 104 112 120))
    (set-variable 'comment-column 40)
)))

;;}}}
;;{{{ Shell mode

(eval-when-compile (require 'shell))

;; This prevents shell commands from being echoed
(add-hook 'comint-mode-hook (function (lambda ()
  (setq comint-process-echoes t))))

;;}}}
;;{{{ Lisp mode

;; Render lambda as greek letter
;; http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
; Lambdas don't look pretty to be honest ;)
;(defun pretty-lambdas ()
;  (font-lock-add-keywords
;   nil `(("(\\(lambda\\>\\)"
;          (0 (progn (compose-region (match-beginning 1) (match-end 1)
;                                    ,(make-char 'greek-iso8859-7 107))
;                    nil))))))
;(add-hook 'emacs-lisp-mode-hook 'pretty-lambdas)

; No tabs!
(add-hook 'emacs-lisp-mode-hook (lambda () (setq indent-tabs-mode ())))

;;}}}
;;{{{ FVWM mode

; http://groups.google.fr/groups?threadm=mailman.2630.1083314129.1061.help-gnu-emacs%40gnu.org
(autoload 'fvwm-mode "fvwm-mode" "Mode fore editing fvwm's config files" t)
(add-to-list 'auto-mode-alist '("\\.fv\\(wm2?\\(rc\\)?\\)?$" . fvwm-mode))

;;}}}
;;{{{ Bison mode

(autoload 'bison-mode "bison-mode.el")
(add-to-list 'auto-mode-alist '("\\.y$" . bison-mode))
;;(add-to-set! auto-mode-alist '("\\.y$" . bison-mode))

;(setq bison-rule-separator-column    8)
;(setq bison-rule-enumeration-column 10)
(setq bison-decl-type-column   8)
(setq bison-decl-token-column 16)


(autoload 'flex-mode "flex-mode")
(add-to-list 'auto-mode-alist '("\\.l$" . flex-mode))
;;(add-to-set! auto-mode-alist '("\\.l$" . flex-mode))

;;}}}
;;{{{ Script mode

(autoload 'script-mode "script-mode" "Mode fore editing scripts" t)

;;}}}

;;}}}
;;{{{ Various features

;;{{{ HTMLize

;; http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el
(autoload 'htmlize-buffer "htmlize" "Convert buffer to HTML" t)
(autoload 'htmlize-region "htmlize" "Convert region to HTML" t)

;;}}}
;;{{{ Replace recent character

;; http://www.emacswiki.org/cgi-bin/wiki/ReplaceRecentCharacter
(load "rrc")

;;}}}
;;{{{ Folding

(require 'folding)

(defconst folding-default-keys-function
  '(folding-bind-backward-compatible-keys))

(define-key folding-mode-map "\C-cf" 'folding-toggle-show-hide)
(define-key folding-mode-map (kbd "C-c RET") 'folding-shift-in)
(define-key folding-mode-map (kbd "C-c DEL") 'folding-shift-out)
(define-key folding-mode-map "\C-c\C-f" 'folding-open-buffer)
(define-key folding-mode-map "\C-cF" 'folding-whole-buffer)

(folding-add-to-marks-list 'php-mode "// {{{" "// }}}" nil t)
(folding-add-to-marks-list 'javascript-mode "// {{{" "// }}}" nil t)
(folding-add-to-marks-list 'css-mode "/* {{{" "/* }}}" " */" t)
(folding-mode-add-find-file-hook)

;;}}}
;;{{{ Different cursor color depending on mode

;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar hcz-set-cursor-color-color "")
(defvar hcz-set-cursor-color-buffer "")
(defun hcz-set-cursor-color-according-to-mode ()
  "Change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color (cond (buffer-read-only "blue")
                     (overwrite-mode "red")
                     (t "yellow"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)

;;}}}
;;{{{ wc

;; Based on http://www.emacswiki.org/cgi-bin/wiki/WordCount
(defun wc (&optional start end)
  "Prints number of lines, words and characters in region or whole buffer."
  (interactive)
  (let ((n 0)
        (start (if mark-active (region-beginning) (point-min)))
        (end (if mark-active (region-end) (point-max))))
    (save-excursion
      (goto-char start)
      (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
    (message "%3d %3d %3d" (count-lines start end) n (- end start))))

;;}}}

;; Start server
(server-start)

;;}}}
;;{{{ Notes in *scratch*

; Notes in *scratch*  v. 0.2
; Copyright (c) 2006 by Michal Nazarewicz (mina86@mina86.com)

(defconst scratch-file (expand-file-name "~/.emacs.scratch")
  "File where content of *scratch* buffer will be read from and saved to.")
(defconst scratch-file-autosave (concat scratch-file ".autosave")
  "File where to autosave content of *scratch* buffer.")

(save-excursion
  (set-buffer (get-buffer-create "*scratch*"))
  (if (file-readable-p scratch-file)
      (if (and (file-readable-p scratch-file-autosave)
               (file-newer-than-file-p scratch-file-autosave scratch-file)
               (y-or-n-p "Recover scratch file? "))
          (insert-file-contents scratch-file-autosave nil nil nil t)
        (insert-file-contents scratch-file nil nil nil t)
        (set-buffer-modified-p nil)))
  (auto-save-mode 1)
  (setq buffer-auto-save-file-name scratch-file-autosave)
;  (setq revert-buffer-function 'scratch-revert)
  (fundamental-mode)
)
(add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
(add-hook 'kill-emacs-hook 'kill-emacs-scratch-save)

(defun scratch-revert (ignore-auto noconfirm)
  (if (file-readable-p scratch-file)
      (progn
        (insert-file-contents scratch-file nil nil nil t)
        (set-buffer-modified-p nil))))

(defun kill-scratch-buffer ()
  (if (not (string-equal (buffer-name (current-buffer)) "*scratch*")) t
    (delete-region (point-min) (point-max))
    (set-buffer-modified-p nil)
    (next-buffer)
    nil))

(defun kill-emacs-scratch-save ()
  (if (get-buffer "*scratch*")
      (save-excursion
        (set-buffer (get-buffer "*scratch*"))
        (write-region nil nil scratch-file)
        (unless (string-equal scratch-file buffer-auto-save-file-name)
          (delete-auto-save-file-if-necessary t)))))

;;}}}
;;{{{ Fun stuff ;)

(defconst wq  "This is not vi!  Use C-x C-c instead.")
(defconst w   "This is not vi!  Use C-x C-s instead.")
(defconst q!  "This is EMACS not vi!  Use C-x C-c instead.")
(defconst wq! "This is EMACS not vi!  Use C-x C-c instead.")

;;}}}

;; Clear messages
;; You may want to comment it out for debuging
(setq message-log-max nil)        ;disable messages

(kill-buffer "*Messages*")        ;kill buffer with messages

(when (file-directory-p gnus-home-directory)
  (gnus))
