;;                                -*- mode: emacs-lisp; lexical-binding: t -*-
;; .emacs  -- Emacs configuration file
;; Copyright 2004-2012 by Michal Nazarewicz (mina86@mina86.com)
;; Some parts of the code may be © by their respective authors.
;;
;;{{{ Compatibility with old Emacses

(unless (boundp 'user-emacs-directory)
  (defvar user-emacs-directory (expand-file-name "~/.emacs.d/")
    "Directory beneath which additional per-user Emacs-specific files are placed.
Various programs in Emacs store information in this directory.
Note that this should end with a directory separator."))

(unless (boundp 'use-empty-active-region)
  (defcustom use-empty-active-region nil
    "If non-nil, an active region takes control even if empty.
This applies to certain commands which, in Transient Mark mode,
apply to the active region if there is one.  If the setting is t,
these commands apply to an empty active region if there is one.
If the setting is nil, these commands treat an empty active
region as if it were not active."
    :type 'boolean
    :version "23.1"
    :group 'editing-basics))

(unless (fboundp 'use-region-p)
  (defun use-region-p ()
    "Return t if certain commands should apply to the region.
Certain commands normally apply to text near point,
but in Transient Mark mode when the mark is active they apply
to the region instead.  Such commands should use this subroutine to
test whether to do that.

This function also obeys `use-empty-active-region'."
    (and (region-active-p)
         (or use-empty-active-region (> (region-end) (region-beginning))))))

(unless (fboundp 'region-active-p)
  (defun region-active-p ()
    "Return t if Transient Mark mode is enabled and the mark is active.
This is NOT the best function to use to test whether a command should
operate on the region instead of the usual behavior -- for that,
use `use-region-p'."
    (and transient-mark-mode mark-active)))

;;}}}
;;{{{ System dependend data and directories

;; Make sure user-emacs-directory is defined
(if (string-equal user-emacs-directory "")
    (setq user-emacs-directory (expand-file-name "~/.emacs.d")))

;; Add  ~/.emacs.d/elisp  to load path
(if (eval-when-compile
      (file-directory-p (concat user-emacs-directory "elisp")))
    (setq load-path (cons (concat user-emacs-directory "elisp") load-path)))

;; Use  aspell
(setq-default ispell-program-name "aspell")

;; Local
(load (concat user-emacs-directory "local.el") t)

;; notmuch
(autoload 'notmuch (concat user-emacs-directory "mail.el") "notmuch mail" t)

;; Packages repositories
(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
                         ("marmalade" . "http://marmalade-repo.org/packages/")
                         ("melpa" . "http://melpa.milkbox.net/packages/")))

;;}}}
;;{{{ Utilities

(defmacro setq-if-bound (name value)
  `(when (boundp (quote ,name))
     (setq ,name ,value)))

(defun -mn-current-local-map ()
  (let ((map (current-local-map)))
    (unless map
      (use-local-map (setq map (make-sparse-keymap))))
    map))

(defmacro set-key (key &rest body)
  (let ((keymap '(current-global-map)))
    (cond
     ((eq :local key)
      (setq keymap '(-mn-current-local-map)
            key    (car body)
            body   (cdr body)))
     ((symbolp key)
      (setq keymap key
            key    (car body)
            body   (cdr body))))

    (list 'define-key keymap key
          (if (and (null (cdr body)) (not (listp (car body))))
              `(quote ,(car body))
            (let (args (int (list 'interactive)))
              (when (eq :args (car body))
                (setq body (cdr body))
                (setq args (car body)
                      int  (list 'interactive (cadr body))
                      body (cddr body)))
              `(function (lambda ,args ,int ,@body)))))))

(defmacro add-lambda-hook (hook &rest body)
  (declare (indent 1))
  (if (and (listp hook) (eq (car hook) 'quote) (listp (cadr hook)))
      (let ((func (make-symbol "func")))
        `(let
          ((,func (function (lambda () ,@body))))
          . ,(mapcar (lambda (h) `(add-hook (quote ,h) ,func))
                     (cadr hook))))
    `(add-hook ,hook (function (lambda () ,@body)))))

;;}}}
;;{{{ Auto-byte-compile

(require 'bytecomp)

(defvar auto-byte-compile-files-list
  (list (or user-init-file
            (concat user-emacs-directory "/init.el"))
        (concat user-emacs-directory "/mail.el"))
  "List of files to auto compile")

(defun auto-byte-compile-file (&optional file match regexp)
  "file can be
- nil in which case value returned by `buffer-file-name' will be used
  unless it returns nil in which case no action will be taken;
- a string which is equivalent to passing list with that string as the
  only element;
- a list of strings representing file names; or
- anything else which is equivalent to passing
  `auto-byte-compile-files-list'.

Entries equal to \".\", \"..\" or ending with \"/.\" or \"/..\"
are ignored.  Directories starting with a dot will be ignored.
If element is a directory it will be processed recursively but if
regexp is nil only files ending with \".el\" will be processed.

match can be
- nil which is equivalent to passing `auto-byte-compile-files-list';
- a string which is equivalent to passing list with that string as the
  only element;
- a list in which case file have to be in that list to be processed; or
- anything else in which case file will be processed regardless of name.

If any element of match is a string ending with a slash ('/') it
is treated as directory name (no checking is done if it is really
a directory or even if it exists) and file is said to match such
entry if it begins with it thus all files in given directory will
match.

If called interacivelly without prefix arg will behave as with
match equal t.  With prefix arg will behave as with match equal
nil.

regexp must be nil which is equivalent with passing a list
containing only empty string or a list of regular expressions
which file have to match to be processed.

So the default is to auto-compile the current file iff it exists
in `auto-byte-compile-files-list'.

Non-string elements in list will be ignored.

Auto-compilation means that file will be byte-compiled iff the
compiled version does not exits or is older then the file
itself."
  (interactive (list (read-file-name "Auto byte compile file:" nil nil t)
                     (not current-prefix-arg)))

  (if (not (or file (setq file (buffer-file-name))))
      0
    (setq file  (cond ((stringp file)  (list file))
                      ((listp   file)  file)
                      (t               auto-byte-compile-files-list))
          match (mapcar (function (lambda (i) (expand-file-name i)))
                        (cond ((not match)     auto-byte-compile-files-list)
                              ((stringp match) (list match))
                              ((listp match)   match)
                              (t               nil))))

    (let (f (n 0))
      (while (setq f (car file))
        (setq file (cdr file) f (expand-file-name f))
        (cond
         ((string-match f "\\(?:^\\|/\\)\\.\\.?$"))
         ((file-directory-p f)
          (unless (string-match f "\\(?:^\\|/\\)\\.")
            (if regexp
                (setq file (append (directory-files f t nil t) file))
              (setq n (+ n (auto-byte-compile-file (directory-files f t nil t)
                                                   (or match t) '("\\.el$")))))))
         ((and (file-newer-than-file-p f (byte-compile-dest-file f))
               (or (not match)
                   (catch 'found
                     (dolist (m match)
                       (if (string= m (if (string-match "/$" m)
                                          (substring f 0 (length m)) f))
                           (throw 'found t)))))
               (or (not regexp)
                   (catch 'found (dolist (r regexp)
                                   (if (string-match r f) (throw 'found t)))))
               (byte-compile-file f)
               (setq n (1+ n))))))
      n)))

(defun auto-byte-compile-buffer (&optional match buffer)
  "Auto compiles file in given buffer (if buffer is nil current
buffer is used) providing that major mode of the buffer is
lisp-mode or emacs-lisp-mode.  match has the same meaning as in
`auto-byte-compile-file'.

If called interacivelly will behave as with match equal t and
buffer equal nil unless prefix argument was given in which case
match will equal nil."
  (interactive (list (not current-prefix-arg) nil))
  (and (buffer-file-name buffer)
       (memq (if buffer (save-current-buffer (set-buffer buffer)
                                             major-mode) major-mode)
               '(lisp-mode emacs-lisp-mode))
       (auto-byte-compile-file (buffer-file-name buffer) match)))


(add-hook 'kill-buffer-hook 'auto-byte-compile-buffer)
(add-lambda-hook 'kill-emacs-hook (auto-byte-compile-file t))

;;}}}
;;{{{ Bindings

;;{{{   Sequence commands

;; Sequence commands  1.3  by me, Michal Nazarewicz ;)
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")


(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
                  ((atom max) (if (and (integerp max) (> max 0))
                                  `(setq seq-times (% (1+ seq-times) ,max))
                                '(setq seq-times (1+ seq-times))))
                  (t          `(let ((max ,max))
                                 (if (and (integerp max) (> max 0))
                                     (setq seq-times (% (1+ seq-times) max))
                                   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
          ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
         ,max
       ,@body
       (setq seq-times 0))))


(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))


(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))

;;}}}
;;{{{   Home/End

;; My home
(defvar my-home-end--point 0)
(defun my-home ()
   "Depending on how many times it was called moves the point to:
once - beginning of line; twice - indent;
three times - beginning of buffer; four times - back to where it was."
   (interactive)
   (seq-times-do nil (setq my-home-end--point (point))
     (beginning-of-line)
     (back-to-indentation)
     (goto-char (point-min))
     (goto-char my-home-end--point)))

(substitute-key-definition 'move-beginning-of-line 'my-home
                           (current-global-map))

;; My end
(defun my-end () "Go to end of line or buffer" (interactive)
  (seq-times-do nil (setq my-home-end--point (point))
    (if (and (boundp 'folding-mode) folding-mode)
        (folding-end-of-line) (end-of-line))
    (forward-paragraph)
    (goto-char (point-max))
    (goto-char my-home-end--point)))

(substitute-key-definition 'move-end-of-line 'my-end (current-global-map))

;;}}}
;;{{{   Pager/Scrolling

(setq-if-bound scroll-error-top-bottom t)
(setq-if-bound scroll-preserve-screen-position t)

;; Makes paging functions work the way god intended
;; http://www.docs.uu.se/~mic/emacs.html
;; pager.el was modified by me
(when (load "pager" t)
  (setq pager-goto-edge t)
  (substitute-key-definition 'scroll-down 'pager-page-up
                             (current-global-map))
  (substitute-key-definition 'scroll-down-command 'pager-page-up
                             (current-global-map))
  (substitute-key-definition 'scroll-up 'pager-page-down
                             (current-global-map))
  (substitute-key-definition 'scroll-up-command 'pager-page-down
                             (current-global-map)))

;;}}}
;;{{{   Save with no blanks

;; Save with no trailing whitespaces
(defun save-no-blanks (&optional arg) (interactive "P")
  (unless arg
    (save-restriction
      (delete-trailing-whitespace)))
  (save-buffer))

(substitute-key-definition 'save-buffer 'save-no-blanks (current-global-map))

;;}}}
;;{{{   Misc

(set-key "\C-x\C-c" :args (arg) "P"
         (when (yes-or-no-p "Do you really want to quit? ")
           (save-buffers-kill-emacs arg))) ; Never kill by mistake


(set-key "\C-h"          delete-backward-char)
(set-key [(backspace)]   delete-backward-char)
(set-key [(delete)]      delete-char)


(defvar mn-window-skip-modes '(compilation-mode)
  "List of major modes that `mn-window-skip-p' should treat as
uninteresting.")

(defvar mn-window-skip-names '("*Compile-Log*" "*Backtrace*" "*compilation*")
  "List of buffer names `mn-window-skip-p' should treat as
uninteresting.  This comes as an addition to
`mn-window-skip-regexp'.")

(defvar mn-window-skip-regexp nil
  "A regexp List of major modes `mn-window-skip-p' should treat as
uninteresting.  This comes as an addition to
`mn-window-skip-names'.")

(defun mn-window-skip-p (window)
  (catch 'done
    ; catch is ugly, I know, but it saves on some indention
    (let ((b (window-buffer window)) n)
      (unless b
        (throw 'done nil))
      (when (memq (with-current-buffer b major-mode) mn-window-skip-modes)
        (throw 'done t))
      (unless (or mn-window-skip-names mn-window-skip-regexp)
        (throw 'done nil))
      (unless (setq n (buffer-name b))
        (throw 'done nil))
      (when (member n mn-window-skip-names)
        (throw 'done t))
      (when (and mn-window-skip-regexp (string-match mn-window-skip-regexp n))
        (throw 'done t))
      nil)))

(defun mn-other-window (count &optional all-frames)
  (interactive "p")
  (let ((func (cond ((> count 0) 'next-window)
                    ((< count 0) 'previous-window))))
    (when func
      (catch 'loop
        (let* ((wnd (selected-window))
               (w   wnd))
          (dotimes (_ (abs count))
            (while (mn-window-skip-p (setq w (funcall func w nil all-frames)))
              (when (eq wnd w)
                (throw 'loop w)))
            (setq wnd w))
        (select-window wnd))))))

(substitute-key-definition 'other-window 'mn-other-window (current-global-map))
(set-key "\C-xO"         other-window)
(set-key "\C-xp"         "\C-u-1\C-xo")          ; C-x p  prev win
(set-key "\C-xP"         "\C-u-1\C-xO")

; don't ask which buffer to kill
(set-key "\C-xk" kill-this-buffer)

(set-key "\C-cr"         revert-buffer)         ; Reload buffer
(set-key "\C-x\C-b" (switch-to-buffer (other-buffer))) ; C-x C-b switch
(set-key [(control ";")] comment-dwim)          ; C-; comments


;; Jump
(require 'ffap)
(defun my-jump () "Jump to the thing at point." (interactive)
  (let ((thing (ffap-guesser))) (if thing (ffap thing)) t))

(set-key [(control return)] my-jump)
(set-key [(control shift mouse-1)] ffap-at-mouse)
(set-key "\C-x\C-f"      ffap)


;; Make l behave as it should in help-mode
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar help-mode-map)  ; silence compiler warning
(add-lambda-hook 'help-mode-hook (set-key help-mode-map "l" help-go-back))

;;}}}
;;{{{   Killing, yanking, X selection, etc

;; Regions, selections and marks
(setq mouse-yank-at-point t       ;mouse yank at point not at cursor   (X-win)
      kill-read-only-ok   t       ;be silent when killing text from RO buffer
      set-mark-command-repeat-pop t
      kill-do-not-save-duplicates t)
(delete-selection-mode 1)         ;deleting region by typing or del (like Win)

(set-key [(shift insert)]
  (let ((mouse-yank-at-point nil))
    (mouse-yank-primary nil)))

;;}}}
;;{{{   DWIW %

;; Based on http://www.zafar.se/bkz/Articles/EmacsTips
(defun match-paren ()
  "Go to the matching parenthesis if on parenthesis."
  (interactive)
  (cond ((and (not (= (point) (point-max)))
              (equal ?( (char-syntax (char-after))))
         (forward-list 1) t)
        ((and (not (= (point) (point-min)))
              (equal ?) (char-syntax (char-before))))
         (backward-list 1) t)))

(set-key [(control ?%)] match-paren)
;; (set-key "%" :args (arg) "p"
;;              (or (match-paren) (self-insert-command (or arg 1))))

;;}}}
;;{{{   Just one space

(defvar smart-space--context nil
  "Store context used in consecutive calls to `smart-space' command.
The first time this function is run, it saves the original point
position and original spacing around the point in this variable.")

(defun smart-space (&optional n preserve-nl-back single-shot)
  "Manipulate spaces around the point in a smart way.

When run as an interactive command, the first time it's called
in a sequence, deletes all spaces and tabs around point leaving
one (or N spaces).  If this does not change content of the
buffer, skips to the second step:

When run for the second time in a sequence, deletes all the
spaces it has previously inserted.

When run for the third time, returns the whitespace and point in
a state encountered when it had been run for the first time.

So, for example, if buffer contains \"foo ^ bar\" with \"^\"
donating the point, calling `smart-space' command will replace
two spaces with a single space, calling it again immediately
after, will remove all spaces, and calling it for the third time
will bring two spaces back together.

If N is negative, delete newlines as well.  However, if
PRESERVE-NL-BACK is non-nill, regardless of the value of N, new line
characters won't be removed prior to the point.

If SINGLE-SHOT is non-nil, will only perform the first step.  In
other words, it will work just like `just-on-space' command."
  (interactive "*p")
  (let ((orig-pos        (point))
        (skip-characters (if (and n (< n 0)) " \t\n\r" " \t"))
        (n               (abs (or n 1))))
    (skip-chars-backward (if preserve-nl-back " \t" skip-characters))
    (constrain-to-field nil orig-pos)
    (cond
     ;; Comman run for the first time or single-shot is non-nil
     ((or single-shot
          (not (equal last-command this-command))
          (not smart-space--context))
      (let* ((start (point))
             (n     (- n (skip-chars-forward " " (+ n (point)))))
             (mid   (point))
             (end   (progn
                      (skip-chars-forward skip-characters)
                      (constrain-to-field nil orig-pos t))))
        (setq smart-space--context  ;; Save for later
              ;; Special handling for case where there was no space at all
              (unless (= start end)
                (cons orig-pos (buffer-substring start (point)))))
        ;; If this run causes no change in buffer content, delete all spaces,
        ;; otherwise delete all excees spaces.
        (delete-region (if (and (not single-shot) (zerop n) (= mid end))
                           start mid) end)
        (dotimes (_ n)
          (insert ?\s))))

     ;; Command run for the second time
     ((not (equal orig-pos (point)))
      (delete-region (point) orig-pos))

     ;; Command run for the third time
     (t
      (insert (cdr smart-space--context))
      (goto-char (car smart-space--context))
      (setq smart-space--context nil)))))

(defun just-one-space (&optional n)
  "Delete all spaces and tabs around point, leaving one space (or N spaces).
If N is negative, delete newlines as well."
  (smart-space n nil t))

(defun mn-smart-space () (interactive) (smart-space -1 t))

(substitute-key-definition 'just-one-space 'mn-smart-space
                           (current-global-map))

;;}}}
;;{{{   Tab - indent or complete

(setq hippie-expand-try-functions-list
      '(
;        try-expand-all-abbrevs
;        try-expand-list
;        try-expand-line
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol)
      hippie-expand-verbose nil)


;; Indent or complete
(defvar indent-or-complete-complete-function 'hippie-expand
  "Function to complete the word when using `indent-or-complete'
It is called with one argument - nil")

(defvar indent-or-complete--last-was-complete nil)

(defun indent-or-complete ()
  "In minibuffer runs `minibuffer-complete'.  Otherwise if
`use-region-p' runs `indent-region'.  Otherwise if point is at end of
a word runs `inent-or-complete-complete-function'.  Otherwise runs
`indent-for-tab-command'."
  (interactive)
  (cond ((and (fboundp 'minibufferp) (minibufferp)) (minibuffer-complete))
        ((use-region-p) (indent-region (region-beginning) (region-end)))
        ((set 'indent-or-complete--last-was-complete
              (or (and (char-before)
                       (= ?w (char-syntax (char-before)))
                       (or (not (char-after))
                           (/= ?w (char-syntax (char-after)))))
                  (and (eq last-command this-command)
                       indent-or-complete--last-was-complete)))
         (funcall indent-or-complete-complete-function nil))
        ((indent-for-tab-command))))

(when (load "auto-complete-config" t)
  (add-to-list 'ac-dictionary-directories "~/.emacs.d/elisp/ac-dict")
  (ac-config-default)

  (setq ac-auto-start 3
        ac-delay 0.1
        ac-auto-show-menu 2
        ac-ignore-case nil
        ac-use-comphist t
        indent-or-complete-complete-function 'auto-complete)

  (set-key ac-completing-map "\M-o" ac-previous)
  (set-key ac-completing-map "\M-p" ac-previous)
  (set-key ac-completing-map "\M-n" ac-next)

  (define-key (current-global-map) "\M-/"
    indent-or-complete-complete-function))

;; (set-key "\t"    indent-or-complete)
;; (set-key [(tab)] indent-or-complete)

(add-lambda-hook 'find-file-hooks
  (unless (eq major-mode 'org-mode)
    (set-key :local [(tab)] indent-or-complete)))

;;}}}
;;{{{   Filling

;; Alt+q - Fill
(unless (fboundp 'fill-paragraph-or-region)
  ;; Taken from emacs 23.0.50.1 (CVS)
  (defun fill-paragraph-or-region (arg)
    "Fill the active region or current paragraph.
IF `use-region-p' then it calls `fill-region', otherwise --
`fill-paragraph'."
    (interactive (progn (barf-if-buffer-read-only)
                        (list (if current-prefix-arg 'full))))
    (if (use-region-p)
        (fill-region (region-beginning) (region-end) arg)
      (fill-paragraph arg))))

(defun my-fill (&optional arg)
  (interactive "*P")
  (if arg
    (fill-region (save-excursion (beginning-of-line) (point))
                 (save-excursion (end-of-line)       (point))
                 (seq-times-nth () () left full right center))
    (fill-paragraph-or-region (seq-times-nth () () left full right center))))

(set-key "\M-q"          my-fill)

;;}}}
;;{{{   Fkeys

;;{{{     F1 - Help

(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
  (let ((var (variable-at-point)))
    (if (symbolp var)
        (describe-variable var)
      (let ((fn (function-called-at-point)))
        (if fn
            (describe-function fn)
          (man (current-word)))))))

(set-key [(f1)]      my-help)

;;}}}
;;{{{     F2 - find configuration files

(set-key [(f2)]         (find-file user-init-file))
(set-key [(control f2)] (find-file (concat user-emacs-directory "/mail.el")))
(set-key [(meta f2)]    (find-file custom-file))
(set-key [(shift f2)]   (find-file "~/.bashrc"))

;;}}}
;;{{{     F5 - Mail

(set-key [(f5)] notmuch)

;;}}}
;;{{{     F7 - spell checking

(require 'ispell)

;; my ispell-change-dictionary bugfix now commited to CVS
;; not need for it here

(defvar mn-spell-dictionaries '("polish" "british")
  "List of dictionaries to cycle through with `mn-spell-switch-dictionary'.")

(eval-after-load "ispell"
  (ispell-change-dictionary "british" t))

(defun mn-spell (&optional lang start end)
  "If LANG is not-nil sets ispell dictionary to lang, then checks
region from START to END for spelling errors.  The default values
for START and END are `region-beginning' and `region-end' if
`use-region-p' or `point-min' and `point-max' otherwise.

If LANG is an empty string local dictionary is set to
nil (ie. the global dictionary is used).

If START >= END this function only sets the dictionary and
returns nil.  Otherwise it returns whatever `ispell-region'
returned."
  (interactive
   (list (completing-read
          "Use new dictionary (RET for current, SPC to complete): "
          (if (fboundp 'ispell-valid-dictionary-list)
              (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)))
  (if lang (ispell-change-dictionary (if (string= lang "") nil lang)))
  (let* ((rp (use-region-p))
         (s  (or start (if rp (region-beginning) (point-min))))
         (e  (or end   (if rp (region-end)       (point-max)))))
    (if (< s e) (ispell-region s e))))

(defun mn-spell-switch-dictionary (&optional arg)
  "Switches dictionary to the next dictionary from `mn-spell-dictionaries'.
With a prefix arg sets global dictionary."
  (interactive "P")
  (ispell-change-dictionary
   (let ((dic (or (and (not arg) ispell-local-dictionary) ispell-dictionary))
         (list mn-spell-dictionaries))
     (while (and list (not (string= (car list) dic))) (setq list (cdr list)))
     (or (cadr list) (car mn-spell-dictionaries)))
   arg))


(set-key [(f7)]         (mn-spell))
(set-key [(control f7)] (mn-spell nil (point)))
(set-key [(meta f7)]    mn-spell-switch-dictionary)
(set-key [(shift f7)]   ispell-word)


(define-globalized-minor-mode global-flyspell-mode
  flyspell-mode mn-turn-flyspell-on)

(defun mn-turn-flyspell-on ()
  (cond ((memq major-mode '(c-mode c++-mode php-mode python-mode perl-mode
                            cperl-mode emacs-lisp-mode lisp-mode scheme-mode
                            diff-mode))
         (flyspell-prog-mode))
        ((memq major-mode '(notmuch-hello-mode notmuch-search-mode
                            notmuch-show-mode)))
        ((flyspell-mode t))))

(global-flyspell-mode 1)

;;}}}
;;{{{     F9 - Compilation

(defconst -mn-compile-common
  " -Wall -Wextra -Wfloat-equal -Wshadow -Wwrite-strings -Winline -Wdisabled-optimization -Wstrict-aliasing=2 -pedantic -DMINA86 -ggdb -O0 -Wpointer-arith -funit-at-a-time")

(defvar mn-compile-vars
  `((("CFLAGS"   "-std=c99 -Werror-implicit-function-declaration -Wunreachable-code -Wstrict-prototypes -Wold-style-definition")
     ("CXXFLAGS" "-std=c++98")
     ("CPPFLAGS" ,-mn-compile-common)
     ("LDFLAGS"  nil))

    (("CFLAGS"   "-std=c89 -Werror-implicit-function-declaration -Wunreachable-code -Wstrict-prototypes -Wold-style-definition")
     ("CXXFLAGS" "-std=c++98 -Wstrict-null-sentinel -Wctor-dtor-privacy -Woverloaded-virtual")
     ("CPPFLAGS" ,-mn-compile-common)
     ("LDFLAGS"  nil)))

  "List of enviroment variables set by `mn-compile' priory to
compilation.  The car of the list is a list of default enviroment
variables to be set and cadr is a list is a list of alternative
enviroment variables.  Each list is a list of two element lists
which car is a enviroment variables name and cadr is value.")


(defun mn-compile (&optional alt recompile touch)
  "If alt is omited or nil sets CFLAGS, CXXFLAGS, CPPFLAGS and
LDFLAGS enviroment variables to `mn-cflags', `mn-cxxflags',
`mn-cppflags', `mn-ldflags' respectively.

If alt is non-nil (or when called interactive with any prefix
argument) sets CFLAGS, CXXFLAGS, CPPFLAGS and LDFLAGS enviroment
variables to `mn-alt-cflags', `mn-alt-cxxflags',
`mn-alt-cppflags', `mn-alt-ldflags' respectively.

Afterwards, if touch is non-nil marks buffer as modified.  Saves
buffer (`save-buffer') and executes `recompile' if recompile is
non-nill or `compile' otherwise."

  (interactive "P")
  (if touch (set-buffer-modified-p t))
  (save-buffer)
  (if (or (eq major-mode 'lisp-mode) (eq major-mode 'emacs-lisp-mode))
      (auto-byte-compile-file nil t)
    (let (v (vars (if alt (cadr mn-compile-vars) (car mn-compile-vars))))
      (while (set 'v (pop vars)) (setenv (car v) (cadr v))))
    (if recompile (recompile) (call-interactively 'compile))))


(set-key [(f9)]         mn-compile)
(set-key [(control f9)] :args (a) "P" (mn-compile a t))
(set-key [(meta f9)]    :args (a) "P" (mn-compile (not a) t t))
(set-key [(shift f9)]   next-error)

(setq compilation-scroll-output 'first-error  ; scroll until first error
      compilation-window-height 12)           ; keep it readable

;;}}}

;;}}}
;;{{{   ISearch mode

(add-hook 'isearch-mode-hook (lambda ()
 (set-key isearch-mode-map [(f1)]      isearch-mode-help)
 (set-key isearch-mode-map "\C-t"      isearch-toggle-regexp)
 (set-key isearch-mode-map "\C-c"      isearch-toggle-case-fold)
 (set-key isearch-mode-map "\C-j"      isearch-edit-string)
 (set-key isearch-mode-map "\C-h"      isearch-del-char)
 (set-key isearch-mode-map [backspace] isearch-del-char)
))

;;}}}
;;{{{   Copy/Kill

;; Copy w/o Selection
;; http://www.emacswiki.org/cgi-bin/wiki/CopyWithoutSelection

(defun copy-word (&optional arg)
  "Copy words at point"
  (interactive "P")
  (let ((beg (progn (if (looking-back "[a-zA-Z]" 1) (backward-word 1)) (point)))
        (end (progn (forward-word arg) (point))))
    (copy-region-as-kill beg end)))

(defun copy-line (&optional _)
  "Save current line into Kill-Ring without mark the line "
  (interactive "P")
  (let ((beg (line-beginning-position))
        (end (line-end-position)))
    (copy-region-as-kill beg end)))

(defun copy-paragraph (&optional arg)
  "Copy paragraphes at point"
  (interactive "P")
  (let ((beg (progn (backward-paragraph 1) (point)))
        (end (progn (forward-paragraph arg) (point))))
    (copy-region-as-kill beg end)))

(set-key "\C-cw"         copy-word)
(set-key "\C-cl"         copy-line)
(set-key "\C-cp"         copy-paragraph)


;; Make C-w, M-w work on word if no selection
(set-key "\C-w" (call-interactively
                 (if (use-region-p) 'kill-region 'kill-word)))
(set-key "\M-w"
  (if (use-region-p)
      (call-interactively 'kill-ring-save)
    (kill-ring-save (point) (progn (forward-word 1) (point)))
    (setq this-command 'kill-region)))

;; C-S-w, M-S-w, C-S-y -- works on registers
(defvar copy-or-append-to-register--register nil)

(defun copy-or-append-to-register (register start end &optional delete append)
  (interactive
   (let ((append-p (equal last-command this-command)))
     (list
      (or (and append-p copy-or-append-to-register--register)
          (read-char (if append-p
                       "Append to register: " "Copy to register: ") nil nil))
      (if (use-region-p) (region-beginning) (point))
      (if (use-region-p) (region-end) (progn (forward-word 1) (point)))
      prefix-arg
      append-p)))
  (if append
      (append-to-register register start end delete)
    (copy-or-append-to-register register start end delete))
  (setq copy-or-append-to-register--register register))

(defun kill-or-append-to-register ()
  (setq prefix-arg t)
  (call-interactively 'copy-or-append-to-register))

(set-key [(control shift w)] copy-or-append-to-register)
(set-key [(meta    shift w)] kill-or-append-to-register)
(set-key [(control shift y)] insert-register)

;;}}}

;;}}}
;;{{{ Syntax highlighting

;; Font lock
(require 'font-lock)
(global-font-lock-mode t)
(setq font-lock-verbose nil)          ;no messages

;; Let customize keep config there
(setq custom-file (concat user-emacs-directory "custom"))
(if (file-exists-p custom-file) (load-file custom-file))
(setq-if-bound auto-byte-compile-files-list
               (cons custom-file auto-byte-compile-files-list))

;; Other
(setq query-replace-highlight t)  ;highlight during query
(setq search-highlight t)         ;highlight incremental search
(show-paren-mode t)               ;show matching parenthesis.
(setq blink-matching-paren-distance nil) ;search for open-paren till point-min

;; Highlight groups of three digits
(add-lambda-hook 'after-init-hook
  (when (fboundp 'global-num3-mode)
    (global-num3-mode t)))

;; Show blanks and FIXME
;; http://www.emacswiki.org/cgi-bin/wiki/EightyColumnRule
(add-lambda-hook 'font-lock-mode-hook
  (unless (eq 'diff-mode major-mode)
    (font-lock-add-keywords nil
     '(("\t+" 0 'my-tab-face t)
       ("^\t\\{4,5\\}" 0 'my-big-indent-face t)
       ("^\t\\{6,\\}" 0 'my-huge-indent-face t)
       ("\\<\\(TODO:?\\)\\>" 1 'my-todo-face t)
       ("\\<\\(FIXME:?\\|XXX\\)\\>" 1 'my-fixme-face t)))))

;;{{{ Set faces

;; Code based on color-theme but simplified
(dolist
    (entry
     '((default
         (t (:stipple nil
             :background "black"
             :foreground "#CCC"
             :inverse-video nil
             :box nil
             :strike-through nil
             :overline nil
             :underline nil
             :slant normal
             :weight normal
             :height 80
             :width normal
             :family "courier"
             :foundry "adobe")))

       (region
        (((type x-toolkit)) (:foreground nil :background "blue"))
        (t (:foreground nil :background nil :inverse-video t)))
       (secondary-selection
        (((type x-toolkit)) (:foreground nil :background "SkyBlue4"))
        (t (:foreground nil :background nil :inverse-video t)))
       (tooltip
        (t (:inherit variable-pitch :background "lightyellow" :foreground "black")))

       (completions-common-part
        (t (:inherit default :foreground "yellow")))
       (completions-first-difference
        (t (:inherit default :foreground "cyan" :weight bold)))

       (custom-button
        (t (:foreground "cyan")))
       (custom-button-face
        (t (:foreground "cyan")))
       (custom-documentation
        (t (:foreground "yellow" :weight bold)))
       (custom-documentation-face
        (t (:foreground "yellow" :weight bold)))
       (custom-group-tag
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-group-tag-face
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-variable-tag
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-variable-tag-face
        (t (:foreground "cyan" :underline t :weight bold)))

       (diff-added
        (t (:inherit diff-changed :foreground "green")))
       (diff-added-face
        (t (:foreground "green" :weight bold)))
       (diff-changed
        (t (:foreground "yellow")))
       (diff-changed-face
        (t (:foreground "yellow" :weight bold)))
       (diff-indicator-added
        (t (:inherit diff-added)))
       (diff-removed
        (t (:inherit diff-changed :foreground "red")))
       (diff-removed-face
        (t (:foreground "red" :weight bold)))

       (font-lock-builtin-face
        (t (:foreground "#99F")))
       (font-lock-comment-face
        (t (:foreground "green" :slant italic)))
       (font-lock-constant-face
        (t (:foreground "aquamarine")))
       (font-lock-doc-face
        (t (:inherit font-lock-comment-face :foreground "#CF0")))
       (font-lock-function-name-face
        (t (:foreground "lightskyblue")))
       (font-lock-keyword-face
        (t (:foreground "#0FF")))
       (font-lock-negation-char-face
        (t nil))
       (font-lock-string-face
        (t (:foreground "lightsalmon")))
       (font-lock-type-face
        (t (:foreground "palegreen")))
       (font-lock-variable-name-face
        (t (:foreground "lightgoldenrod")))
       (font-lock-warning-face
        (t (:foreground "pink" :weight bold)))
       (fringe
        (t (:background "#002")))
       (header-line
        (t (:inherit mode-line :background "#006" :foreground "#FFF" :box nil)))
       (help-argument-name
        (t (:inherit font-lock-variable-name-face)))
       (highlight
        (t (:background "#060" :underline "#0F0")))
       (hl-line
        (t (:background "#003")))
       (lazy-highlight
        (t (:background "paleturquoise4")))
       (link
        (t (:foreground "cyan" :underline t)))
       (link-visited
        (t (:inherit link :foreground "#96F")))
       (match
        (t (:background "RoyalBlue3")))

       (mode-line
        (t (:background "#009" :foreground "white" :box nil)))
       (mode-line-buffer-id
        (t (:foreground "#9FF" :weight bold)))
       (mode-line-highlight
        (t (:background "#00F")))
       (mode-line-inactive
        (t (:inherit mode-line :box nil :background nil :foreground "#CCC")))

       (widget-button
        (t (:background "blue" :foreground "cyan" :weight bold)))
       (widget-button-face
        (t (:background "blue" :foreground "cyan" :weight bold)))
       (widget-field
        (t (:background "blue")))
       (widget-field-face
        (t (:background "blue")))

       (my-tab-face
        (((class color) (min-colors 216)) (:background "#666"))
        (t (:background "yellow")))
       (my-big-indent-face
        (((class color) (min-colors 216)) (:background "#966"))
        (t (:background "red")))
       (my-huge-indent-face
        (((class color) (min-colors 216)) (:background "#C66"))
        (t (:background "magenta")))
       (my-fixme-face
        (t :background "red" :foreground "white" :weight bold))
       (my-todo-face
        (t :foreground "red" :weight bold))

       (num3-face-even
        (t :underline nil :weight normal :background "#000" :foreground "#CFF"))))
  (let ((face (car entry)) (spec (cdr entry)))
    (unless (facep face)
      (make-empty-face face))
    (condition-case var
        (progn
          (put face 'face-override-spec spec)
          (face-spec-set face spec))
      (error (message "Error using spec %S: %S" spec var)))))

;;}}}

;;}}}
;;{{{ Misc small config

(setq use-dialog-box nil)         ;never use dialog boxes

;; Frame apperence
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(if (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(setq default-frame-alist '((width . 80)
                            (right-fringe . 4)
                            (left-fringe  . 4)
                            (menu-bar-lines . 0)
                            (tool-bar-lines . 0)
                            (vertical-scroll-bars)
                            (foreground-color . "gray")
                            (background-color . "black")
                            (background-mode . dark)
                            (wait-for-wm . nil)))

;; Modeline
(setq line-number-mode t          ;show line number in modeline
      column-number-mode t)       ;show column number in modeline

(setq mode-line-format
      '("%e"
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        mode-line-buffer-identification
        "  "
        mode-line-position
        vc-mode
        " "
        mode-line-modes
        (which-func-mode ("" which-func-format))
        (global-mode-string ("" global-mode-string))
        "%-")

      mode-line-position
      '(:eval (let* ((min (point-min)) (max (point-max))
                     (wide (and (= min 1) (= max (1+ (buffer-size))))))
                (concat
                 (if wide "(" "[")
                 (if column-number-mode "%2c, " "")
                 (if line-number-mode "%2l/" "")
                 (number-to-string (1+ (count-lines min max)))
                 (if wide ")" "]"))))

      mode-line-modes
      '("("
        (:propertize
         ("" mode-name mode-line-process minor-mode-alist)
         help-echo "mouse-1: major mode, mouse-2: major mode help, mouse-3: toggle minor modes"
         mouse-face mode-line-highlight
         local-map (keymap
                    (header-line keymap
                                 (down-mouse-3 . mode-line-mode-menu-1))
                    (mode-line keymap
                               (down-mouse-3 . mode-line-mode-menu-1)
                               (mouse-2 . describe-mode)
                               (down-mouse-1 . mouse-major-mode-menu))))
        ") "))


;; Other
(icomplete-mode 1)                ;nicer completion in minibuffer
(setq icomplete-prospects-height 2) ; don't spam my minibuffer
(set-key minibuffer-local-map "\C-c"  ; C-c clears minibuffer
  (delete-minibuffer-contents))
(setq suggest-key-bindings 3)     ;suggestions for shortcut keys for 3 seconds
(setq frame-title-format "Emacs") ;frame title format
(setq history-delete-duplicates t)
(setq inhibit-splash-screen   t   ;don't show splash screen
      inhibit-startup-echo-area-message "mina86" ;don't show "For info..." message
      inhibit-startup-buffer-menu t) ;don't show buffer menu when oppening
                                  ; many files               (EMACS 21.4+)
(setq sentence-end-double-space 1 ;sentance end with double space
      sentance-end-base "[.?!…][]\"'”)}]*" ; "…" also ends sentence
      require-final-newline t)    ;always end file with NL
(setq truncate-lines nil)         ;wrap lines
(fset 'yes-or-no-p 'y-or-n-p)     ;make yes/no be y/n
(set-default 'indicate-empty-lines t) ;show empty lines at the end of file
(set-default 'indicate-buffer-boundaries t) ;show buffer boundries on fringe
(setq x-alt-keysym 'meta)         ;treat Alt as Meta even if real Meta found
(setq gc-cons-threshold 4000000)  ;bytes before garbage collection
(setq ange-ftp-try-passive-mode t);passive FTP
(blink-cursor-mode -1)            ;do not blink cursor
(setq blink-cursor-alist '((t      . box)  ;seriously, don't blink,
                           (box    . box)) ;blink-cursor-mode does not
      cursor-type 'box)                    ;work for me.
(setq-if-bound compilation-auto-jump-to-first-error t)
(setq-if-bound line-move-visual nil) ;move by logical lines not screen lines

;; Saving etc
(when (fboundp recentf-mode)
  (recentf-mode nil))           ;no recent files
(setq backup-by-copying-when-linked t) ;preserve hard links
(auto-compression-mode 1)         ;automatic compression
(setq make-backup-files nil)      ;no backup
(global-auto-revert-mode 1)       ;automaticly reload buffer when changed


;; Indention
(defun set-tab (tab &optional stop-list)
  "Sets `tab-stop-list' to a list of all positive from smallest to
largest which are multiplications of TAB and are lower or equal 120.

If called interactively user will be prompted for desired width.  With
prefix argument, `indent-tabs-mode' will also be set to t.

If TAB is negative, `indent-tabs-mode' will be set to nil and an
absolute value will be taken.

This function also tries to set indent-level for current buffer's
major mode.  This is not very inteligent nor has complete list of
rules so it is likely not to work."
  (interactive "nTab-width: ")
  (let ((negative (< tab 0)))
    (setq tab-width (abs tab))
    (set (make-local-variable 'tab-stop-list)
         (or stop-list (number-sequence tab 120 tab-width)))
    (mapc
     (lambda (var)
       (when (boundp var)
         (set (make-local-variable var) tab-width)))
     '(c-basic-offset perl-indent-level cperl-indent-level  js-indent-level
       sh-basic-offset sh-indentation))
    (cond
     (negative (setq indent-tabs-mode nil))
     (prefix-arg (setq indent-tabs-mode t)))))

(setq indent-tabs-mode t)         ;indent using tabs
(set-tab 8)                       ;tab width and stop list


;; Scrolling/moving
(setq scroll-step 1)              ;scroll one line
(setq hscroll-step 1)             ;scroll one column
(setq next-line-add-newlines nil) ;no new lines with down arrow key


;; Blink Scroll Lock LED instead of beep
(setq visible-bell nil)           ;no visual bell
(setq ring-bell-function (function (lambda ()
  (call-process-shell-command "xset led 3; xset -led 3" nil 0 nil))))


;; Each list element as new paragraph
;; http://www.emacswiki.org/cgi-bin/wiki/FillParagraph
(setq paragraph-start    " *\\([*+-]\\|\\([0-9]+\\|[a-zA-Z]\\)[.)]\\|$\\)"
      paragraph-separate "$")


;; GDB
(setq gdb-many-windows t
      gdb-show-main t
      gdb-use-separate-io-buffer nil)


;; Do not break line after single character when filling
(defun fill-single-char-nobreak-p ()
  "Don't break line after a single character."
  (save-excursion
    (skip-chars-backward " \t")
    (backward-char 2)
    (looking-at "[[:space:]][a-zA-Z]")))

(add-to-list 'fill-nobreak-predicate 'fill-single-char-nobreak-p)


;; Sort words in region
;; http://www.emacswiki.org/emacs/SortWords
(defun sort-words (reverse beg end)
  "Sort words in region alphabetically, in REVERSE if negative.
Prefixed with negative \\[universal-argument], sorts in reverse.
The variable `sort-fold-case' determines whether alphabetic case
affects the sort order.
See `sort-regexp-fields'."
  (interactive "P\nr")
  (sort-regexp-fields reverse "\\w+" "\\&" beg end))

;;}}}
;;{{{ Major Modes

;;{{{   CC Mode

(eval-when-compile ; make compiler happy
  (require 'cc-mode)
  (load "google-c-style" t))

(add-lambda-hook 'c-initialization-hook
  (c-add-style
   "mina86"
   '((c-basic-offset . 8)             ; 8-char wide indention...
     (tab-width . 8)                  ; ...which equals single tab...
     (indent-tabs-mode . t)           ; ...so use tabs
     (c-comment-only-line-offset . 0)  ; XXX no idea what it does
     (c-label-minimum-indentation . 1) ; no min. indention for labels

     (c-cleanup-list                 ; Clean ups
      brace-else-brace                 ; "} else {" in one line
      brace-elseif-brace               ; "} else if (...) {" in one line
      brace-catch-brace                ; "} catch (...) {" in one line
      defun-close-semi                 ; "};" together
      )

     (c-offsets-alist                ; Indention levels:
      ; Don't indent inside namespaces, extern, etc
      (incomposition          . 0)
      (inextern-lang          . 0)
      (inmodule               . 0)
      (innamespace            . 0)

      ; Preprocessor macros
      (cpp-define-intro       c-lineup-cpp-define +)
      (cpp-macro              . [ 0 ])
      (cpp-macro-cont         . +)

      ; Brace after newline newer indents
      (block-open             . 0)
      (brace-entry-open       . 0)
      (brace-list-open        . 0)
      (class-open             . 0)
      (composition-open       . 0)
      (defun-open             . 0)
      (extern-lang-open       . 0)
      (inline-open            . 0)
      (module-open            . 0)
      (namespace-open         . 0)
      (statement-case-open    . 0)
      (substatement-open      . 0)

      ; Obviously, do not indent closing brace
      (arglist-close          . 0)
      (block-close            . 0)
      (brace-list-close       . 0)
      (class-close            . 0)
      (composition-close      . 0)
      (defun-close            . 0)
      (extern-lang-close      . 0)
      (inline-close           . 0)
      (module-close           . 0)
      (namespace-close        . 0)

      ; Obviously, indent next line after opening brace and single statements
      (defun-block-intro      . +)
      (statement-block-intro  . +)
      (substatement           . +)

      ; Handle nicely multi line argument lists
      (arglist-close c-lineup-arglist 0)
      (arglist-cont          mn-c-lineup-argcont c-lineup-gcc-asm-reg +)
      (arglist-cont-nonempty mn-c-lineup-argcont c-lineup-gcc-asm-reg c-lineup-arglist +)
      (arglist-intro . c-lineup-arglist-intro-after-paren)

      ; Misc
      (brace-list-intro       . +)     ; Indent elements in brace-lists
      (brace-list-entry       . 0)
      (c      . c-lineup-C-comments)   ; Indent comments nicely
      (comment-intro          . c-lineup-comment)
      (catch-clause           . 0)     ; catch/finally where try
      (do-while-closure       . 0)     ; while (...) where do
      (else-clause            . 0)     ; else where if
      (func-decl-cont         . +)     ; Indent stuff after function
      (friend                 . 0)     ; friend need no additional indention
      (inclass                . +)     ; Indent stuff inside class...
      (access-label           . -)     ; ...expect for access labels
      (inexpr-statement       . 0)     ; No unneeded indent in ({ ... })...
      (inexpr-class           . 0)     ; ...& anonymous classes
      (inher-intro            . +)     ; ndent & lineup inheritance list
      (inher-cont             . c-lineup-multi-inher)
      (member-init-intro      . +)     ; Indent & lineup initialisation list
      (member-init-cont       . c-lineup-multi-inher)
      (label                  . [ 0 ]) ; Labels always on first column
      (substatement-label     . [ 0 ])
      (statement              . 0)     ; Statement same as line above...
      (statement-cont c-lineup-cascaded-calls +) ; ...but indent cont.
      (statement-case-intro   . +)     ; Indent statements in switch...
      (case-label             . 0)     ; ...but not the labels
      (stream-op . c-lineup-streamop)  ; Lineup << operators in C++
      (string . c-lineup-dont-change)  ; Do not touch strings!
      (template-args-cont c-lineup-template-args +) ; Lineup template args
      (topmost-intro          . 0)     ; Topmost stay topmost
      (topmost-intro-cont     c-lineup-topmost-intro-cont 0)

      ; Other stuff I don't really care about
      ; I keep it here for the sake of having all symbols specified.
      (inlambda               . c-lineup-inexpr-block)
      (knr-argdecl            . 0)
      (knr-argdecl-intro      . +)
      (lambda-intro-cont      . +)
      (objc-method-args-cont  . c-lineup-ObjC-method-args)
      (objc-method-call-cont
       ;c-lineup-ObjC-method-call-colons
       c-lineup-ObjC-method-call +)
      (objc-method-intro      . [0])
      )

     ; I don't care about anything that is below -- not using any
     ; automagick -- but for the sake of having everything set I'll keep
     ; it here.

     (c-hanging-braces-alist         ; Auto new lines around braces
      ; In most cases new line after open brace and both before and
      ; after close brace.  The "before" is however ommited
      ; from *-close symbols because when editing normally we will
      ; be on the new line already -- if we're not, user probably
      ; knows better.
      (defun-open             after)
      (defun-close            after)
      (class-open             after)
      (class-close            after)
      (inline-open            after)
      (inline-close           after)
      (extern-lang-open       after)
      (extern-lang-close      after)
      (namespace-open         after)
      (namespace-close        after)
      (module-open            after)
      (module-close           after)
      (composition-open       after)
      (composition-close      after)

      ; No new line after closing brace if it matches do { or if (...) {
      (block-open             after)
      (substatement-open      after)
      (block-close            . c-snug-do-while)

      ; With brace-lists however, do nothing automatically -- user knows
      ; better
      (brace-list-open        )
      (brace-list-close       )
      (brace-list-intro       )
      (brace-entry-open       )

      ; Others
      (statement-cont         )
      (statement-case-open    after)
      (inexpr-class-open      )
      (inexpr-class-close     )
      (arglist-cont-nonempty  )
      )

     (c-hanging-colons-alist
      ; Add new line after labels
      (case-label             after)
      (label                  after)
      (access-label           after)
      ; But nothing else
      (member-init-intro      )
      (inher-intro            )

      (c-hanging-semi&comma-criteria
       (mn-c-semi&comma-no-newlines-if-open-brace
        c-semi&comma-no-newlines-before-nonblanks
        c-semi&comma-inside-parenlist))
      )))


  (defun mn-c-semi&comma-no-newlines-if-open-brace ()
    "Prevents newline after semicolon if there is an open brace
on the same line.  Function is a bit stupid and does not check if
the open brace was real open brace or part of comment/string."
    (when (let ((p (point))) (save-excursion (forward-line 0)
                                             (search-forward "{" p t)))
      'stop))

  (defun mn-c-lineup-argcont (elem)
    "Line up a continued argument's operands (assumes there
will be a single space after an operator ifit starts the line).

foo(xyz, aaa +
         bbb               <- c-lineup-argcont
       + ccc               <- c-lineup-argcont
      << ccc               <- c-lineup-argcont
      ==  eee);            <- c-lineup-argcont
if (foo
 || bar)                   <- c-lineup-argcont

Only continuation lines like this are touched, nil is returned on lines
which are the start of an argument.

Within a gcc asm block, \":\" is recognized as an argument separator,
but of course only between operand specifications, not in the expressions
for the operands.

Works with: arglist-cont, arglist-cont-nonempty."
    (let ((ret (c-lineup-argcont elem)))
      (if (and (vectorp ret)
               (save-excursion
                 (back-to-indentation)
                 (looking-at
                  (eval-when-compile
                    (regexp-opt
                     (list
                      "+" "+=" "++" "-" "-=" "--" "*" "*=" "/" "/=" "%"
                      "%=" "^" "^=" "&" "&=" "&&" "|" "|=" "||" "<<"
                      "<<=" ">>" ">>=" "<" "<=" ">" ">=" "=" "==" ":"
                      "::" "?"))))))
          (vector (- (elt ret 0) (- (match-end 0) (match-beginning 0)) 1))
        ret)))


  (setq c-default-style '((awk-mode . "awk")
                          (other    . "mina86")))

  (add-lambda-hook 'c-common-mode-hook
    (when buffer-file-name
      (let ((fn (file-name-nondirectory buffer-file-name)))
        (set (make-local-variable 'compile-command)
             (concat "make -k "
                     (substring
                      fn 0 (string-match "\\.[^\\.]*$" fn 1)))))))

  (when (and (load "google-c-style" t)
             (boundp 'google-c-style))
    (c-add-style "google" google-c-style)
    (add-lambda-hook 'c-mode-hook
      (and buffer-file-name
           (string-match-p "/google3/" buffer-file-name)
           (c-set-style "google")))))

;;}}}
;;{{{   HTML/XML & comapny Mode

;; Create a link out of the preceeding word if it appears to be a URL
(if (load "thingatpt" t)
    (defun mn-linkify-maybe ()
      "If the word before cursor appears to be an URL wrap it around
in a <a href=\"...\">...</a>.  Returns whether it happend."
      (interactive "*")
      (when (save-excursion
              (save-restriction
                (let ((end (point)))
                  (beginning-of-line)
                  (narrow-to-region (point) end)
                  (looking-at
                   (concat ".*\\(" thing-at-point-url-regexp "\\)\\'")))))
        (let ((url (delete-and-extract-region (match-beginning 1)
                                              (match-end 1))))
          (insert "<a href=\"" url "\">" url "</a>"))))
  (defun mn-linkify-maybe ()
    "If the word before cursor appears to be an URL wrap it
around in a <a href=\"...\">...</a>.  Returns whether it happend.

This is however a stub implementation (because thingatpt could not be loaded) which does nothing and returns nul."
    nil))


(defun mn-magick-self-insert-command (spec &optional default when-prefix)
  "If prefix argument is not nil calls WHEN-PREFIX with single
argument being a `prefix-numeric-value' or the `prefix-arg'.

Otherwise looks through SPEC which is a list of 3-element
lists (called rules):
  (regexp length action)
Rule is said to match if `point' is at least LENGTH characters from
`point-min' and REGEXP matches starting at position LENGTH characters
earlier then `point'.  ACTION of first rule that matches is performed.
If no rule matches DEFAULT is treated as action to perform.

If ACTION to perform is a string (DEFAULT may not be a string)
then `replace-match' is called otherwise it is assumed ACTION is
a function and it is called with single argument 1.

DEFAUTL and WHEN-PREFIX defaults to `self-insert-command'."
  (if prefix-arg
      (funcall (or when-prefix  'self-insert-command)
               (prefix-numeric-value prefix-arg))
    (let ((action (catch 'done
                    (let ((dist (- (point) (point-min))))
                      (dolist (rule spec)
                        (when (>= dist (cadr rule))
                          (save-excursion
                            (backward-char (cadr rule))
                            (when (looking-at (car rule))
                              (throw 'done (cadr (cdr rule))))))))
                    default)))
      (if (stringp action) (replace-match action)
        (funcall (or action 'self-insert-command) 1)))))

(defmacro mn-magick-self-insert-define
  (map key spec &optional default when-prefix)
  `(define-key ,map ,key
     (lambda () (interactive ,"*")
       (mn-magick-self-insert-command ,spec ,default ,when-prefix))))

(defun mn-xml-configure-bindings (mode-map)
  (mn-magick-self-insert-define mode-map " "
                                '(("[^<]\\b\\w" 2 "\\& ")
                                  ("^\\w"       1 "\\& ")
                                  ("&#160;"     6 " ")
                                  (" "          1 " "))
                                (lambda (n)
                                  (mn-linkify-maybe)
                                  (self-insert-command n)))
  (mn-magick-self-insert-define mode-map "<"
                                '(("<"          1 "&lt;")))
  (mn-magick-self-insert-define mode-map ">"
                                '(("&#160;&#8211;" 13 " -->")
                                  (" –"         2 " -->")
                                  (">"          1 "&gt;")))
  (mn-magick-self-insert-define mode-map "&"
                                '(("&"          1 "&amp;")))
  (mn-magick-self-insert-define mode-map "."
                                '(("\\.\\."     2 "…")))
  (mn-magick-self-insert-define mode-map "\""
                                '(("\""         1 "&quot;")))
  (mn-magick-self-insert-define mode-map "~"
                                '(("~"          1 " ")))
  (mn-magick-self-insert-define mode-map "-"
                                '(("[-!]-"      2 nil)
                                  (" -"         2 " –")
                                  ("-"          1 " –")
                                  ("–"          1 "—")
                                  ("&#8211;"    7 "—")))
  (mn-magick-self-insert-define mode-map [(backspace)]
                                '(("&lt;"       4 "<")
                                  ("«"          1 "&lt;")
                                  ("&gt;"       4 ">")
                                  ("»"          1 "&gt;")
                                  ("&amp;"      5 "&")
                                  ("&quot;"     6 "\"")
                                  ("&#8230;"    7 "..")
                                  ("…"          1 "..")
                                  ("&#8220;"    7 "`")
                                  ("&#8221;"    7 "'")
                                  ("&#8222;"    7 ",")
                                  ("&#8212;"    7 "&#8211;")
                                  ("&#82\\(?:11\\|09\\);" 7 "-")
                                  ("&.....;"    7 "")
                                  ("&....;"     6 "")
                                  ("&...;"      5 "")
                                  ("&..;"       4 ""))
                                'delete-backward-char
                                'delete-backward-char)
  (setq indent-tabs-mode nil
        next-error-function 'nxml-next-error))

;; http://github.com/nelhage/elisp/blob/master/dot-emacs
(declare-function rng-first-error "rng-valid")
(declare-function rng-next-error "rng-valid")
(defun nxml-next-error (arg reset)
  (if reset (rng-first-error))
  (rng-next-error arg))

(eval-when-compile (require 'sgml-mode))
(eval-after-load "sgml-mode"
  (add-lambda-hook 'sgml-mode-hook
    (mn-xml-configure-bindings sgml-mode-map)))

(when (fboundp 'nxml-mode)
  (eval-when-compile (require 'nxml-mode))
  (setq nxml-slash-auto-complete-flag t
        nxml-auto-insert-xml-declaration-flag t
        nxml-bind-meta-tab-to-complete-flag t)
  (add-to-list 'auto-mode-alist '("\\.\\(?:x\\|ht\\)ml\\'" . nxml-mode))
  (eval-after-load "nxml-mode"
    (add-lambda-hook 'nxml-mode-hook
      (mn-xml-configure-bindings nxml-mode-map))))

(defun replace-string-pairs (list)
  (let* ((mark  (use-region-p))
         (start (if mark (region-beginning) (point)))
         (end   (if mark (region-end) (point-max))))
    (save-excursion
      (dolist (pair list)
        (let ((diff (- (length (cdr pair)) (length (car pair)))))
          (goto-char start)
          (while (search-forward (car pair) end t)
            (setq end (+ end diff))
            (replace-match (cdr pair) nil t)))))))

(defun html-escape ()
  "Replaces HTML special characters with HTML entities.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer."
  (interactive)
  (replace-string-pairs
   '(("&" . "&amp;") ("<" . "&lt;") (">" . "&gt;") ("\"" . "&quot;"))))

(defun html-unescape ()
  "Replaces (some) HTML entities with characters.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer."
  (interactive)
  (replace-string-pairs
   '(("&amp;" . "&") ("&lt;" . "<") ("&gt;" . ">") ("&quot;" . "\""))))

;;}}}
;;{{{   (La)TeX and nroff mode

;; Helper for tex-space
(defmacro my-tex-looking-back (regexp len)
  "Returns non-nil if text LEN chars backward matches REGEXP
prefixed with \\b."
  `(save-excursion
     (backward-char ,len)
     (looking-at ,(concat "\\b" regexp))))

;; insert '~' or '\ ' instead of ' ' in LaTeX when needed
;; Also removes '~' when 2nd space added
;; http://www.debianusers.pl/article.php?aid=39
(defun tex-space (arg) (interactive "P")
  (cond
   ((re-search-backward "\\~" (- (point) 1) t)
    (delete-char 1) (self-insert-command (prefix-numeric-value arg)))
   (arg (self-insert-command (prefix-numeric-value arg)))
   ((my-tex-looking-back "[a-z]" 1)
    ;    (my-tex-looking-back "[a-z][a-z]" 2))
    (insert-char ?~ 1))
   ((or (my-tex-looking-back "[a-z][a-z]\\." 3)
        (my-tex-looking-back "\\(?:tz[wn]\\|it[pd]\\)\\." 4))
    (insert "\\ "))
   (t (self-insert-command 1))))

(eval-when-compile (require 'tex-mode))
(add-lambda-hook '(tex-mode-hook latex-mode-hook)
  (set-key tex-mode-map " " tex-space))


;; Insert '\ ' instead of ' ' in nroff when needed
;; Also removes '\' when 2nd space added
(defun nroff-space (arg) (interactive "p")
  (cond
   ((re-search-backward "\\\\ " (- (point) 2) t)
    (delete-char 1) (forward-char) (self-insert-command arg))
   ((> arg 1) (self-insert-command arg))
   ((my-tex-looking-back "[a-z]" 1)
;        (my-tex-looking-back "[a-z][a-z]" 2))
;        (my-tex-search-back "do\\|na\\|od\\|po\\|za\\|we\\|to\\|co" 2))
    (insert-char ?\\ 1) (self-insert-command 1))
   (t (self-insert-command 1))))

(eval-when-compile (require 'nroff-mode))

(add-lambda-hook 'nroff-mode-hook
  (set-key nroff-mode-map " " nroff-space))

;;}}}
;;{{{   Generate serialVersionUID in Java

(defun mn-serialVersionUID (&optional insert)
  "When called interactivly or with a non nil argument inserts
a random 64-bit hexadecimal integer prefixed with \"0x\" and
suffixed with \"L\".  When called with nil argument or with
argument ommited returns that number."
  (interactive (list t))
  (if insert
      (insert (mn-serialVersionUID))
    (format "0x%04x%04x%04x%04xL"
            (random 65536) (random 65536)
            (random 65536) (random 65536))))

(add-lambda-hook 'java-mode-hook
  (add-lambda-hook 'write-contents-functions
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "serialVersionUID\s+=\s+[0-9a-fA-FxX]+L;"
                                  nil t)
          (replace-match
           (concat "serialVersionUID = " (mn-serialVersionUID) ";")
           nil t))))))

;;}}}
;;{{{   Misc

;; Text mode
(add-lambda-hook 'text-mode-hook
  (auto-fill-mode t)
  (set-tab 8)
  (setq-if-bound word-wrap t))

;; Assembler mode
(add-lambda-hook 'asm-mode-hook
  (set-tab 8 16)
  (setq comment-column 40))

;; Org mode
(setq org-insert-mode-line-in-empty-file t)

;; Lisp/Scheme mode
;; No tabs! and if opening file with tabs, assume 8-char wide
(add-lambda-hook '(emacs-lisp-mode-hook lisp-mode-hook scheme-mode-hook)
  (setq indent-tabs-mode nil) (set-tab 8))

;; Sawfish mode
(autoload 'sawfish-mode "sawfish" "Mode for editing Sawfish config files")
(add-to-list 'auto-mode-alist '("sawfish/?rc\\'" . sawfish-mode))
(add-to-list 'auto-mode-alist '("\\.jl\\'" . sawfish-mode))

;; Bison mode
(autoload 'bison-mode "bison-mode.el")
(add-to-list 'auto-mode-alist '("\\.y$" . bison-mode))
(setq bison-decl-type-column   8)
(setq bison-decl-token-column 16)

;; Flex
(autoload 'flex-mode "flex-mode")
(add-to-list 'auto-mode-alist '("\\.l$" . flex-mode))

;; Use cperl-mode for Perl
(mapc
 (lambda (list)
   (mapc
    (lambda (pair)
      (if (eq (cdr pair) 'perl-mode)
          (setcdr pair 'cperl-mode)))
    list))
 (list auto-mode-alist interpreter-mode-alist))
(setq cperl-invalid-face nil  ; don't highlight trailing white-space
      cperl-highlight-variables-indiscriminately t
      cperl-electric-backspace-untabify nil)

;; shell-script-mode
(setq sh-indent-for-case-label 0
      sh-indent-for-case-alt '+)

;;}}}

;;}}}
;;{{{ Various features

;;{{{   uniquify

(when (load "uniquify" t)
  (setq uniquify-buffer-name-style 'reverse
        uniquify-strip-common-suffix t))

;;}}}
;;{{{   HTMLize

;; http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el
(autoload 'htmlize-buffer "htmlize" "Convert buffer to HTML" t)
(autoload 'htmlize-region "htmlize" "Convert region to HTML" t)

;;}}}
;;{{{   Folding

(when (load "folding" t)
  (defconst folding-default-keys-function
    '(folding-bind-backward-compatible-keys))

  (set-key folding-mode-map "\C-cf"                    folding-toggle-show-hide)
  (set-key folding-mode-map [(control ?c) (return)]    folding-shift-in)
  (set-key folding-mode-map [(control ?c) (delete)]    folding-shift-out)
  (set-key folding-mode-map [(control ?c) (backspace)] folding-shift-out)
  (set-key folding-mode-map "\C-c\C-f"                 folding-open-buffer)
  (set-key folding-mode-map "\C-cF"                    folding-whole-buffer)
  (set-key folding-mode-map "\C-e"                     my-end)

  (folding-add-to-marks-list 'php-mode        "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'sawfish-mode    ";;{{{" ";;}}}" nil t)
  (folding-add-to-marks-list 'javascript-mode "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'css-mode        "/* {{{" "/* }}}" " */" t)

  (folding-mode-add-find-file-hook))

;;}}}
;;{{{   Different cursor color depending on mode

;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar hcz-set-cursor-color-color "")
(defvar hcz-set-cursor-color-buffer "")
(defun hcz-set-cursor-color-according-to-mode ()
  "Change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color (cond (buffer-read-only "blue")
                     (overwrite-mode "red")
                     (t "yellow"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)

(set-cursor-color (setq hcz-set-cursor-color-color "yellow"))

;;}}}
;;{{{   Notes in *scratch*

;; Notes in *scratch*  v. 0.3
;; Copyright (c) 2006 by Michal Nazarewicz (mina86@mina86.com)
;; Released under GNU GPL

(defconst scratch-file (concat user-emacs-directory "scratch")
  "File where content of *scratch* buffer will be read from and saved to.")
(defconst scratch-file-autosave (concat scratch-file ".autosave")
  "File where to autosave content of *scratch* buffer.")

(with-current-buffer (get-buffer-create "*scratch*")
  (if (file-readable-p scratch-file)
      (if (and (file-readable-p scratch-file-autosave)
               (file-newer-than-file-p scratch-file-autosave scratch-file))
;               (y-or-n-p "Recover scratch file? "))
          (insert-file-contents scratch-file-autosave nil nil nil t)
        (insert-file-contents scratch-file nil nil nil t)
        (set-buffer-modified-p nil)))
  (auto-save-mode 1)
  (setq buffer-auto-save-file-name scratch-file-autosave)
  (set (make-local-variable 'revert-buffer-function) 'scratch-revert)
  (fundamental-mode))

(defun scratch-revert (_ignore-auto _noconfirm)
  (when (file-readable-p scratch-file)
    (insert-file-contents scratch-file nil nil nil t)
    (set-buffer-modified-p nil)))

(defun kill-scratch-buffer ()
  (not (when (string-equal (buffer-name (current-buffer)) "*scratch*")
         (delete-region (point-min) (point-max))
         (set-buffer-modified-p nil)
         (next-buffer)
         t)))

(defun kill-emacs-scratch-save ()
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region nil nil scratch-file)
    (unless (string-equal scratch-file buffer-auto-save-file-name)
      (delete-auto-save-file-if-necessary t))))

(add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
(add-hook 'kill-emacs-hook 'kill-emacs-scratch-save)

;;}}}

;; Start server
(unless (and (fboundp 'daemonp) (daemonp))
  (server-start))

;;}}}
