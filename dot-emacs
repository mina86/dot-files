;;                           -*- mode: emacs-lisp; indent-tabs-mode: nil -*-
;; .emacs  -- Emacs configuration file
;; Copyright 2004-2008 by Michal Nazarewicz (mina86@mina86.com)
;;
;;{{{ Compatibility with old Emacses

(unless (boundp 'user-emacs-directory)
  (defvar user-emacs-directory (expand-file-name "~/.emacs.d/")
    "Directory beneath which additional per-user Emacs-specific files are placed.
Various programs in Emacs store information in this directory.
Note that this should end with a directory separator."))

(unless (boundp 'use-empty-active-region)
  (defcustom use-empty-active-region nil
    "If non-nil, an active region takes control even if empty.
This applies to certain commands which, in Transient Mark mode,
apply to the active region if there is one.  If the setting is t,
these commands apply to an empty active region if there is one.
If the setting is nil, these commands treat an empty active
region as if it were not active."
    :type 'boolean
    :version "23.1"
    :group 'editing-basics))

(unless (fboundp 'use-region-p)
  (defun use-region-p ()
    "Return t if certain commands should apply to the region.
Certain commands normally apply to text near point,
but in Transient Mark mode when the mark is active they apply
to the region instead.  Such commands should use this subroutine to
test whether to do that.

This function also obeys `use-empty-active-region'."
    (and (region-active-p)
         (or use-empty-active-region (> (region-end) (region-beginning))))))

(unless (fboundp 'region-active-p)
  (defun region-active-p ()
    "Return t if Transient Mark mode is enabled and the mark is active.
This is NOT the best function to use to test whether a command should
operate on the region instead of the usual behavior -- for that,
use `use-region-p'."
    (and transient-mark-mode mark-active)))

;;}}}
;;{{{ System dependend data and directories

;; Gnus
(when (eval-when-compile (string-match "^erwin" system-name))
  (setq gnus-home-directory (expand-file-name "~/.gnus")
        gnus-init-file
        (concat gnus-home-directory
                (if (file-exists-p (concat gnus-home-directory "/.gnus"))
                    "/.gnus" "/.gnus.el"))
        load-path (cons (concat gnus-home-directory "/gnus/lisp") load-path)
        message-directory (concat gnus-home-directory "/Mail"))
  (eval-after-load "info"
    (if (load "gnus-load")
        (setq Info-default-directory-list
              (cons (concat gnus-home-directory "/gnus/texi")
                    Info-default-directory-list)))))

;; Make sure user-emacs-directory is defined
(if (string-equal user-emacs-directory "")
    (setq user-emacs-directory (expand-file-name "~/.emacs.d/")))

;; Add  ~/.emacs.d/elisp  to load path
(if (eval-when-compile
      (file-directory-p (concat user-emacs-directory "elisp")))
    (setq load-path (cons (concat user-emacs-directory "elisp") load-path)))

;; Use  aspell
(setq-default ispell-program-name "aspell")

;;}}}
;;{{{ Auto-byte-compile

(require 'bytecomp)

(defvar auto-byte-compile-files-list
  (let ((ghd (or (and (boundp 'gnus-home-directory) gnus-home-directory)
                 (expand-file-name "~/.gnus"))))
    (cond
     ((string-match "\\.elc$" (or user-init-file "/home/mina86/.emacs.d/init.el"))
      (list (substring user-init-file 0 -4)
            (substring user-init-file 0 -1)
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))
     (t
      (list user-init-file
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))))
  "List of files to auto compile")

(defun auto-byte-compile-file (&optional file match regexp)
  "file can be
- nil in which case value returned by `buffer-file-name' will be used
  unless it returns nil in which case no action will be taken;
- a string which is equivalent to passing list with that string as the
  only element;
- a list of strings representing file names; or
- anything else which is equivalent to passing
  `auto-byte-compile-files-list'.

Entries equal to \".\", \"..\" or ending with \"/.\" or \"/..\"
are ignored.  Directories starting with a dot will be ignored.
If element is a directory it will be processed recursively but if
regexp is nil only files ending with \".el\" will be processed.

match can be
- nil which is equivalent to passing `auto-byte-compile-files-list';
- a string which is equivalent to passing list with that string as the
  only element;
- a list in which case file have to be in that list to be processed; or
- anything else in which case file will be processed regardless of name.

If any element of match is a string ending with a slash ('/') it
is treated as directory name (no checking is done if it is really
a directory or even if it exists) and file is said to match such
entry if it begins with it thus all files in given directory will
match.

If called interacivelly without prefix arg will behave as with
match equal t.  With prefix arg will behave as with match equal
nil.

regexp must be nil which is equivalent with passing a list
containing only empty string or a list of regular expressions
which file have to match to be processed.

So the default is to auto-compile the current file iff it exists
in `auto-byte-compile-files-list'.

Non-string elements in list will be ignored.

Auto-compilation means that file will be byte-compiled iff the
compiled version does not exits or is older then the file
itself."
  (interactive (list (read-file-name "Auto byte compile file:" nil nil t)
                     (not current-prefix-arg)))

  (if (not (or file (setq file (buffer-file-name))))
      0
    (setq file  (cond ((stringp file)  (list file))
                      ((listp   file)  file)
                      (t               auto-byte-compile-files-list))
          match (mapcar (function (lambda (i) (expand-file-name i)))
                        (cond ((not match)     auto-byte-compile-files-list)
                              ((stringp match) (list match))
                              ((listp match)   match)
                              (t               nil))))

    (let (f (n 0))
      (while (setq f (car file))
        (setq file (cdr file) f (expand-file-name f))
        (cond
         ((string-match f "\\(?:^\\|/\\)\\.\\.?$"))
         ((file-directory-p f)
          (unless (string-match f "\\(?:^\\|/\\)\\.")
            (if regexp
                (setq file (append (directory-files f t nil t) file))
              (setq n (+ n (auto-byte-compile-file (directory-files f t nil t)
                                                   (or match t) '("\\.el$")))))))
         ((and (file-newer-than-file-p f (byte-compile-dest-file f))
               (or (not match)
                   (catch 'found
                     (dolist (m match)
                       (if (string= m (if (string-match "/$" m)
                                          (substring f 0 (length m)) f))
                           (throw 'found t)))))
               (or (not regexp)
                   (catch 'found (dolist (r regexp)
                                   (if (string-match r f) (throw 'found t)))))
               (byte-compile-file f)
               (setq n (1+ n))))))
      n)))

(defun auto-byte-compile-buffer (&optional match buffer)
  "Auto compiles file in given buffer (if buffer is nil current
buffer is used) providing that major mode of the buffer is
lisp-mode or emacs-lisp-mode.  match has the same meaning as in
`auto-byte-compile-file'.

If called interacivelly will behave as with match equal t and
buffer equal nil unless prefix argument was given in which case
match will equal nil."
  (interactive (list (not current-prefix-arg) nil))
  (and (buffer-file-name buffer)
       (memq (if buffer (save-current-buffer (set-buffer buffer)
                                             major-mode) major-mode)
               '(lisp-mode emacs-lisp-mode))
       (auto-byte-compile-file (buffer-file-name buffer) match)))


(add-hook 'kill-buffer-hook 'auto-byte-compile-buffer)
(add-hook 'kill-emacs-hook (function (lambda () (auto-byte-compile-file t))))

;;}}}
;;{{{ Bindings

(defmacro set-key-lambda (key &rest body)
  `(global-set-key ,key (function (lambda () (interactive) ,@body))))

;;{{{   Sequence commands

;; Sequence commands  1.3  by me, Michal Nazarewicz ;)
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")


(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
                  ((atom max) (if (and (integerp max) (> max 0))
                                  `(setq seq-times (% (1+ seq-times) ,max))
                                '(setq seq-times (1+ seq-times))))
                  (t          `(let ((max ,max))
                                 (if (and (integerp max) (> max 0))
                                     (setq seq-times (% (1+ seq-times) max))
                                   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
          ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
         ,max
       ,@body
       (setq seq-times 0))))


(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))


(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))

;;}}}
;;{{{   Movement

; Recently I started using Programmers' Dvorak keyboard layout and so
; I had some problems moving in the text.  However I've noticed that
; I never use C-o and o is placed simetrically to n on Dvorak layout
; so it's a perfect candidate for previous line!
(global-set-key "\C-o" 'previous-line)

; Now, I've also got an ergonomic keyboard wich Back/Forward buttons
; under my thumbs -- they seem perfect for horizontal movemetn.
(global-set-key [(XF86Back)]    'backward-char)
(global-set-key [(XF86Forward)] 'forward-char)
; Also adding control bindings so I don't have to release it when
; using C-o and C-n
(global-set-key [(control XF86Back)]    'backward-char)
(global-set-key [(control XF86Forward)] 'forward-char)

;;}}}
;;{{{   Home/End

;; My home
(defvar my-home-end--point 0)
(defun my-home ()
   "Depending on how many times it was called moves the point to:
once - beginning of line; twice - indent;
three times - beginning of buffer; four times - back to where it was."
   (interactive)
   (seq-times-do nil (setq my-home-end--point (point))
     (beginning-of-line)
     (back-to-indentation)
     (goto-char (point-min))
     (goto-char my-home-end--point)))

(substitute-key-definition 'move-beginning-of-line 'my-home
                           (current-global-map))


;; My end
(defun my-end () "Go to end of line or buffer" (interactive)
  (seq-times-do nil (setq my-home-end--point (point))
    (if folding-mode (folding-end-of-line) (end-of-line))
    (forward-paragraph)
    (goto-char (point-max))
    (goto-char my-home-end--point)))

(substitute-key-definition 'move-end-of-line 'my-end (current-global-map))

;;}}}
;;{{{   Pager/Scrolling

;; Makes paging functions work the way god intended
;; http://www.docs.uu.se/~mic/emacs.html
;; pager.el was modified by me
(require 'pager)
(setq pager-goto-edge t)

(substitute-key-definition 'scroll-down 'pager-page-up   (current-global-map))
(substitute-key-definition 'scroll-up   'pager-page-down (current-global-map))

(set-key-lambda [(meta up)]     (scroll-down 1))    ; Alt+Up
(set-key-lambda [(meta kp-8)]   (scroll-down 1))
(set-key-lambda "\M-p"          (scroll-down 1))
(set-key-lambda [(meta down)]   (scroll-up   1))    ; Alt+Dn
(set-key-lambda [(meta kp-2)]   (scroll-up   1))
(set-key-lambda "\M-n"          (scroll-up   1))

(global-set-key [(meta shift up)]   'pager-row-up)  ; Alt+Shift+Up
(global-set-key [(meta shift kp-8)] 'pager-row-up)
(global-set-key "\M-P"              'pager-row-up)
(global-set-key [(meta shift down)] 'pager-row-down); Alt+Shift+Down
(global-set-key [(meta shift kp-2)] 'pager-row-down)
(global-set-key "\M-N"              'pager-row-down)

;;}}}
;;{{{   Save with no blanks

;; Save with no trailing whitespaces
;; XXX there is a delete-trailing-whitespace function which might be
;; added to write-file-hooks.
(defun save-no-blanks (&optional arg) (interactive "P")
  (unless arg
    (save-excursion
      (save-restriction
        (widen)
        (goto-char 0) (perform-replace "[ \t]+$" "" nil t nil)
        (goto-char (point-max))
        (unless (>= (skip-chars-backward "\n") -2)
          (delete-region (1+ (point)) (point-max))))))
  (save-buffer))

(substitute-key-definition 'save-buffer 'save-no-blanks (current-global-map))
;(global-set-key "\C-x\C-s"      'save-no-blanks)

;;}}}
;;{{{   Misc

(global-set-key "\C-x\C-C"      'kill-emacs) ; Kill while daemon
(global-set-key "\C-z"          'undo) ; I like undo better; never used C-z


(global-set-key "\C-h"          'delete-backward-char)
(global-set-key [(backspace)]   'delete-backward-char)
(global-set-key [(delete)]      'delete-char)
(global-set-key [(control backspace)] 'backward-kill-word)
(global-set-key [(control delete)] 'kill-word)


;(global-set-key "\C-xg"         'goto-line)             ; C-x g  goto line
;Since 22.1 M-g M-g and M-g g are goto line
(global-set-key "\C-xp"         "\C-u-1\C-xo")          ; C-x p  prev win
(global-set-key "\C-xk"         'kill-this-buffer)      ; don't ask which
                                                        ; buffer to kill
(global-set-key "\C-cr"         'revert-buffer)         ; Reload buffer
(set-key-lambda "\C-x\C-b" (switch-to-buffer (other-buffer))) ; C-x C-b switch
(global-set-key [(control ";")] 'comment-dwim)          ; C-; comments

;(require 'imenu)
;(global-set-key [(shift mouse-3)] 'imenu)
;(setq imenu-sort-function 'imenu--sort-by-name)


;; Jump
(require 'ffap)
(defun my-jump () "Jump to the thing at point." (interactive)
  (let ((thing (ffap-guesser))) (if thing (ffap thing)) t))

(global-set-key [(control return)] 'my-jump)
(global-set-key [(control shift mouse-1)] 'ffap-at-mouse)
(global-set-key "\C-x\C-f"      'ffap)


;; Make l behave as it should in help-mode
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(add-hook 'help-mode-hook
          (function (lambda () (define-key help-mode-map "l" 'help-go-back))))

;; Copy to X-clipboard on C-x c or C-x w
(defun x-set-clipboard-content-from-selection (begin end)
  "Sets X clipboard content to selected text."
  (interactive "r")
  (let ((x-select-enable-clipboard t))
    (x-select-text (buffer-substring begin end))))

;; Paste from X-clipboard on C-x y
(defun x-yank-clipboard (&optional arg)
  "Yanks cntents of X clipboard to current buffer."
  (interactive "*P")
  (let ((text (x-selection-value 'CLIPBOARD)))
    (when text
      ;; Copied from yank
      (push-mark (point))
      (insert-for-yank text)
      (if (consp arg)
          ;; This is like exchange-point-and-mark, but doesn't
          ;; activate the mark.  It is cleaner to avoid activation,
          ;; even though the command loop would deactivate the mark
          ;; because we inserted text.
          (goto-char (prog1 (mark t)
                       (set-marker (mark-marker) (point) (current-buffer)))))
      ;; Pretend we are yank.
      (setq this-command 'yank)
      nil)))

(global-set-key "\C-xc"        'x-set-clipboard-content-from-selection)
(global-set-key "\C-xw"        'x-set-clipboard-content-from-selection)
(global-set-key "\C-xy"        'x-yank-clipboard)

;;}}}
;;{{{   DWIW %

;; Based on http://www.zafar.se/bkz/Articles/EmacsTips
(defun match-paren ()
  "Go to the matching parenthesis if on parenthesis."
  (interactive)
  (cond ((and (not (= (point) (point-max)))
              (equal ?( (char-syntax (char-after))))
         (forward-list 1) t)
        ((and (not (= (point) (point-min)))
              (equal ?) (char-syntax (char-before))))
         (backward-list 1) t)))

(defun dwim-match-paren (arg)
  (interactive "*p")
  (or (match-paren) (self-insert-command (or arg 1))))

(global-set-key [(control ?%)] 'match-paren)
(global-set-key "%" 'dwim-match-paren)

;;}}}
;;{{{   Just one space

(defun mn-just-one-space ()
  "When called for the first time Works just like `just-one-space'.
When called second time deletes all spaces, tabs and new lines after
the point."
  (interactive)
  (if (equal last-command this-command)
      (delete-region (point)
                     (save-excursion (skip-chars-forward " \t\n") (point)))
    (just-one-space)))

(substitute-key-definition 'just-one-space 'mn-just-one-space
                           (current-global-map))

;;}}}
;;{{{   Tab - indent or complete


(setq hippie-expand-try-functions-list
      '(
;        try-expand-all-abbrevs
;        try-expand-list
;        try-expand-line
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol)
      hippie-expand-verbose nil)


;; Indent or complete
(defvar indent-or-complete-complete-function 'hippie-expand
  "Function to complete the word when using `indent-or-complete'
It is called with one argument - nil")

(defvar indent-or-complete--last-was-complete nil)

(defun indent-or-complete ()
  "In minibuffer runs `minibuffer-complete'.  Otherwise if
`use-region-p' runs `indent-region'.  Otherwise if point is at end of
a word runs `inent-or-complete-complete-function'.  Otherwise runs
`indent-for-tab-command'."
  (interactive)
  (cond ((and (fboundp 'minibufferp) (minibufferp)) (minibuffer-complete))
        ((use-region-p) (indent-region (region-beginning) (region-end)))
        ((set 'indent-or-complete--last-was-complete
              (or (and (= ?w (char-syntax (char-before)))
                       (not (= ?w (char-syntax (char-after)))))
                  (and (eq last-command this-command)
                       indent-or-complete--last-was-complete)))
         (funcall indent-or-complete-complete-function nil))
        ((indent-for-tab-command))))

;(global-set-key "\t"    'indent-or-complete)
;(global-set-key [(tab)] 'indent-or-complete)
(global-set-key "\M-/" indent-or-complete-complete-function)
(add-hook 'find-file-hooks (function (lambda ()
  (unless (eq major-mode 'org-mode)
    (local-set-key [(tab)] 'indent-or-complete)))))
(save-current-buffer
  (set-buffer "*scratch*")
  (local-set-key [(tab)] 'indent-or-complete))

;;}}}
;;{{{   Centering

(defvar centerer--window-start nil)

(defun centerer ()
  "Repositions current line: once - middle, twice - top, three and
four times - `reposition-window', five times - bottom, six times -
where it was at the beginning.
   If performing some action doesn't really change position of the
window function skips to another step."
   (interactive)
   (let ((i 0) (old (window-start)))
     (while (and (<= (setq i (1+ i)) 6) (equal (window-start) old))
       (seq-times-do nil (setq centerer--window-start (window-start))
         (recenter)
         (recenter 0)
         (reposition-window)
         (reposition-window)
         (recenter -1)
         (set-window-start (selected-window) centerer--window-start)))))

(global-set-key "\C-l"     'centerer)

;;}}}
;;{{{   Filling

;; Alt+q - Fill
(unless (fboundp 'fill-paragraph-or-region)
  ;; Taken from emacs 23.0.50.1 (CVS)
  (defun fill-paragraph-or-region (arg)
    "Fill the active region or current paragraph.
IF `use-region-p' then it calls `fill-region', otherwise --
`fill-paragraph'."
    (interactive (progn (barf-if-buffer-read-only)
                        (list (if current-prefix-arg 'full))))
    (if (use-region-p)
        (fill-region (region-beginning) (region-end) arg)
      (fill-paragraph arg))))

(defun my-fill (&optional arg)
  (interactive "*P")
  (if arg
    (fill-region (save-excursion (beginning-of-line) (point))
                 (save-excursion (end-of-line)       (point))
                 (seq-times-nth () () left full right center))
    (fill-paragraph-or-region (seq-times-nth () () left full right center))))

(global-set-key "\M-q"          'my-fill)

;; Alt+Q - Unfill
(defun th-unfill-paragraph-or-region ()
  "Do the opposite of `fill-paragraph-or-region'; stuff all lines
in the current paragraph into a single long line."
  (interactive)
  (let ((fill-column most-positive-fixnum))
    (if (use-region-p)
        (fill-region (region-beginning) (region-end) nil)
      (fill-paragraph nil)))
  (setq deactivate-mark nil))

(global-set-key "\M-Q"          'th-unfill-paragraph-or-region)

;;}}}
;;{{{   Fkeys

;;{{{     Key sequences

(global-set-key "\eOP"       [(f1)])
(global-set-key "\e[[A"      [(f1)])
(global-set-key "\eOQ"       [(f2)])
(global-set-key "\e[[B"      [(f2)])
(global-set-key "\eOR"       [(f3)])
(global-set-key "\e[[C"      [(f3)])
(global-set-key "\eOS"       [(f4)])
(global-set-key "\e[[D"      [(f4)])
(global-set-key "\e[15~"     [(f5)])
(global-set-key "\e[[E"      [(f5)])
(global-set-key "\e[17~"     [(f6)])
(global-set-key "\e[18~"     [(f7)])
(global-set-key "\e[19~"     [(f8)])
(global-set-key "\e[20~"     [(f9)])
(global-set-key "\e[21~"     [(f10)])
(global-set-key "\e[23~"     [(f11)])
(global-set-key "\e[24~"     [(f12)])
(global-set-key "\eO5P"      [(control f1)])
(global-set-key "\eO5Q"      [(control f2)])
(global-set-key "\eO5R"      [(control f3)])
(global-set-key "\eO5S"      [(control f4)])
(global-set-key "\e[15;5~"   [(control f5)])
(global-set-key "\e[17;5~"   [(control f6)])
(global-set-key "\e[18;5~"   [(control f7)])
(global-set-key "\e[19;5~"   [(control f8)])
(global-set-key "\e[20;5~"   [(control f9)])
(global-set-key "\e[21;5~"   [(control f10)])
(global-set-key "\e[23;5~"   [(control f11)])
(global-set-key "\e[24;5~"   [(control f12)])
(global-set-key "\eO6P"      [(control shift f1)])
(global-set-key "\eO6Q"      [(control shift f2)])
(global-set-key "\eO6R"      [(control shift f3)])
(global-set-key "\eO6S"      [(control shift f4)])
(global-set-key "\e[15;6~"   [(control shift f5)])
(global-set-key "\e[17;6~"   [(control shift f6)])
(global-set-key "\e[18;6~"   [(control shift f7)])
(global-set-key "\e[19;6~"   [(control shift f8)])
(global-set-key "\e[20;6~"   [(control shift f9)])
(global-set-key "\e[21;6~"   [(control shift f10)])
(global-set-key "\e[23;6~"   [(control shift f11)])
(global-set-key "\e[24;6~"   [(control shift f12)])
(global-set-key "\eO3P"      [(meta f1)])
(global-set-key "\eO3Q"      [(meta f2)])
(global-set-key "\eO3R"      [(meta f3)])
(global-set-key "\eO3S"      [(meta f4)])
(global-set-key "\e[15;3~"   [(meta f5)])
(global-set-key "\e[17;3~"   [(meta f6)])
(global-set-key "\e[18;3~"   [(meta f7)])
(global-set-key "\e[19;3~"   [(meta f8)])
(global-set-key "\e[20;3~"   [(meta f9)])
(global-set-key "\e[21;3~"   [(meta f10)])
(global-set-key "\e[23;3~"   [(meta f11)])
(global-set-key "\e[24;3~"   [(meta f12)])
(global-set-key "\eO4P"      [(meta shift f1)])
(global-set-key "\eO4Q"      [(meta shift f2)])
(global-set-key "\eO4R"      [(meta shift f3)])
(global-set-key "\eO4S"      [(meta shift f4)])
(global-set-key "\e[15;4~"   [(meta shift f5)])
(global-set-key "\e[17;4~"   [(meta shift f6)])
(global-set-key "\e[18;4~"   [(meta shift f7)])
(global-set-key "\e[19;4~"   [(meta shift f8)])
(global-set-key "\e[20;4~"   [(meta shift f9)])
(global-set-key "\e[21;4~"   [(meta shift f10)])
(global-set-key "\e[23;4~"   [(meta shift f11)])
(global-set-key "\e[24;4~"   [(meta shift f12)])
(global-set-key "\eO2P"      [(shift f1)])
(global-set-key "\e[23~"     [(shift f1)])
(global-set-key "\eO2Q"      [(shift f2)])
(global-set-key "\e[24~"     [(shift f2)])
(global-set-key "\eO2R"      [(shift f3)])
(global-set-key "\e[25~"     [(shift f3)])
(global-set-key "\eO2S"      [(shift f4)])
(global-set-key "\e[26~"     [(shift f4)])
(global-set-key "\e[15;2~"   [(shift f5)])
(global-set-key "\e[28~"     [(shift f5)])
(global-set-key "\e[17;2~"   [(shift f6)])
(global-set-key "\e[29~"     [(shift f6)])
(global-set-key "\e[18;2~"   [(shift f7)])
(global-set-key "\e[31~"     [(shift f7)])
(global-set-key "\e[19;2~"   [(shift f8)])
(global-set-key "\e[32~"     [(shift f8)])
(global-set-key "\e[20;2~"   [(shift f9)])
(global-set-key "\e[33~"     [(shift f9)])
(global-set-key "\e[21;2~"   [(shift f10)])
(global-set-key "\e[34~"     [(shift f10)])
(global-set-key "\e[23;2~"   [(shift f11)])
(global-set-key "\e[24;2~"   [(shift f12)])

;;}}}
;;{{{     F1 - Help

(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
  (let ((var (variable-at-point)))
    (if (symbolp var)
        (describe-variable var)
      (let ((fn (function-called-at-point)))
        (if fn
            (describe-function fn)
          (man (current-word)))))))

(global-set-key [(f1)]      'my-help)

;;}}}
;;{{{     F2 - find configuration files

(defmacro mn-kbd-find-file (file)
  `(function (lambda () (interactive) (find-file ,file))))

(global-set-key [(f2)]         (mn-kbd-find-file
                                (if (string-match "\\.elc$" user-init-file)
                                    (if (file-exists-p
                                         (substring user-init-file 0 -1))
                                        (substring user-init-file 0 -1)
                                        (substring user-init-file 0 -4))
                                  user-init-file)))
(global-set-key [(control f2)] (mn-kbd-find-file "~/.gnus/.gnus.el"))
(global-set-key [(meta f2)]    (mn-kbd-find-file custom-file))
;(global-set-key [(shift f2)]   (mn-kbd-find-file "~/.bashrc"))

;;}}}
;;{{{     F5 - Gnus

;; http://www.emacswiki.org/cgi-bin/wiki/SwitchToGnus

(defun switch-to-gnus-or-get-new-news ()
  "If already in Gnus group retrive new news otherwise, if Gnus is
running, switch to Gnus group buffer, otherwise start Gnus."
  (interactive)
  (cond
   ((eq major-mode 'gnus-group-mode)
    (and (fboundp 'gnus-group-get-new-news) (gnus-group-get-new-news)))
   ((and (boundp 'gnus-group-buffer) (fboundp 'gnus-alive-p) (gnus-alive-p))
    (switch-to-buffer (with-no-warnings gnus-group-buffer)))
   ((gnus))))

(global-set-key [(f5)]      'switch-to-gnus-or-get-new-news)
;(set-key-lambda [(control f5)] (let ((b (current-buffer)))
;                                 (switch-to-buffer (other-buffer))
;                                 (bury-buffer b)))

;;}}}
;;{{{     F7 - spell checking

(require 'ispell)

;; my ispell-change-dictionary bugfix now commited to CVS
;; not need for it here

(defvar mn-spell-dictionaries '("polish" "british")
  "List of dictionaries to cycle through with `mn-spell-switch-dictionary'.")

(eval-after-load "ispell"
  (ispell-change-dictionary "polish" t))

(defun mn-spell (&optional lang start end)
  "If LANG is not-nil sets ispell dictionary to lang, then checks
region from START to END for spelling errors.  The default values
for START and END are `region-beginning' and `region-end' if
`use-region-p' or `point-min' and `point-max' otherwise.

If LANG is an empty string local dictionary is set to
nil (ie. the global dictionary is used).

If START >= END this function only sets the dictionary and
returns nil.  Otherwise it returns whatever `ispell-region'
returned."
  (interactive
   (list (completing-read
          "Use new dictionary (RET for current, SPC to complete): "
          (if (fboundp 'ispell-valid-dictionary-list)
              (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)))
  (if lang (ispell-change-dictionary (if (string= lang "") nil lang)))
  (let* ((rp (use-region-p))
         (s  (or start (if rp (region-beginning) (point-min))))
         (e  (or end   (if rp (region-end)       (point-max)))))
    (if (< s e) (ispell-region s e))))

(defun mn-spell-switch-dictionary (&optional arg)
  "Switches dictionary to the next dictionary from `mn-spell-dictionaries'.
With a prefix arg sets global dictionary."
  (interactive "P")
  (ispell-change-dictionary
   (let ((dic (or (and (not arg) ispell-local-dictionary) ispell-dictionary))
         (list mn-spell-dictionaries))
     (while (and list (not (string= (car list) dic))) (setq list (cdr list)))
     (or (cadr list) (car mn-spell-dictionaries)))
   arg))


(set-key-lambda [(f7)]         (mn-spell))
(set-key-lambda [(control f7)] (mn-spell nil (point)))
(global-set-key [(meta f7)]    'mn-spell-switch-dictionary)
(set-key-lambda [(shift f7)]
 (call-interactively
  (if (and (boundp 'flyspell-mode) flyspell-mode)
      'flyspell-correct-word-before-point 'ispell-word)))

;;}}}
;;{{{     F8 - Keyboard macros

; since 22.1 this is on by defaault
(global-set-key [(f3)] 'kmacro-start-macro-or-insert-counter)
(global-set-key [(f4)] 'kmacro-end-or-call-macro)

;;}}}
;;{{{     F9 - Compilation

(defconst -mn-compile-common
  " -Wall -Wextra -Wfloat-equal -Wshadow -Wwrite-strings -Winline -Wdisabled-optimization -Wstrict-aliasing=2 -pedantic -DMINA86 -ggdb -O0 -Wpointer-arith -funit-at-a-time")

(defvar mn-compile-vars
  `((("CFLAGS"   "-std=c99 -Werror-implicit-function-declaration -Wunreachable-code -Wstrict-prototypes -Wold-style-definition")
     ("CXXFLAGS" "-std=c++98")
     ("CPPFLAGS" ,-mn-compile-common)
     ("LDFLAGS"  nil))

    (("CFLAGS"   "-std=c89 -Werror-implicit-function-declaration -Wunreachable-code -Wstrict-prototypes -Wold-style-definition")
     ("CXXFLAGS" "-std=c++98 -Wstrict-null-sentinel -Wctor-dtor-privacy -Woverloaded-virtual")
     ("CPPFLAGS" ,-mn-compile-common)
     ("LDFLAGS"  nil)))

  "List of enviroment variables set by `mn-compile' priory to
compilation.  The car of the list is a list of default enviroment
variables to be set and cadr is a list is a list of alternative
enviroment variables.  Each list is a list of two element lists
which car is a enviroment variables name and cadr is value.")


(defun mn-compile (&optional alt recompile touch)
  "If alt is omited or nil sets CFLAGS, CXXFLAGS, CPPFLAGS and
LDFLAGS enviroment variables to `mn-cflags', `mn-cxxflags',
`mn-cppflags', `mn-ldflags' respectively.

If alt is non-nil (or when called interactive with any prefix
argument) sets CFLAGS, CXXFLAGS, CPPFLAGS and LDFLAGS enviroment
variables to `mn-alt-cflags', `mn-alt-cxxflags',
`mn-alt-cppflags', `mn-alt-ldflags' respectively.

Afterwards, if touch is non-nil marks buffer as modified.  Saves
buffer (`save-buffer') and executes `recompile' if recompile is
non-nill or `compile' otherwise."

  (interactive "P")
  (if touch (set-buffer-modified-p t))
  (save-buffer)
  (if (or (eq major-mode 'lisp-mode) (eq major-mode 'emacs-lisp-mode))
      (auto-byte-compile-file nil t)
    (let (v (vars (if alt (cadr mn-compile-vars) (car mn-compile-vars))))
      (while (set 'v (pop vars)) (setenv (car v) (cadr v))))
    (if recompile (recompile) (call-interactively 'compile))))


(global-set-key [(f9)]      'mn-compile)               ; F9    compile
(global-set-key [(control f9)]                         ; C-F9  recompile
                (function (lambda (a) (interactive "P") (mn-compile a t))))
(global-set-key [(meta f9)]                            ; M-F9  force alt comp.
                (function (lambda (a) (interactive "P") (mn-compile (not a) t t))))
(global-set-key [(shift f9)] 'next-error)

(setq compilation-scroll-output 'first-error  ; scroll until first error
      compilation-window-height 12)           ; keep it readable

;;}}}

;;}}}
;;{{{   ISearch mode

(add-hook 'isearch-mode-hook (lambda ()
 (define-key isearch-mode-map "\C-h"      'isearch-mode-help)
 (define-key isearch-mode-map "\C-t"      'isearch-toggle-regexp)
 (define-key isearch-mode-map "\C-c"      'isearch-toggle-case-fold)
 (define-key isearch-mode-map "\C-j"      'isearch-edit-string)
; (define-key isearch-mode-map "\C-h"      'isearch-del-char)
 (define-key isearch-mode-map [backspace] 'isearch-del-char)
))

;;}}}
;;{{{   Copy/Kill

;; Copy w/o Selection
;; http://www.emacswiki.org/cgi-bin/wiki/CopyWithoutSelection

(defun copy-word (&optional arg)
  "Copy words at point"
  (interactive "P")
  (let ((beg (progn (if (looking-back "[a-zA-Z]" 1) (backward-word 1)) (point)))
        (end (progn (forward-word arg) (point))))
    (copy-region-as-kill beg end)))

(defun copy-line (&optional arg)
  "Save current line into Kill-Ring without mark the line "
  (interactive "P")
  (let ((beg (line-beginning-position))
        (end (line-end-position)))
    (copy-region-as-kill beg end)))

(defun copy-paragraph (&optional arg)
  "Copy paragraphes at point"
  (interactive "P")
  (let ((beg (progn (backward-paragraph 1) (point)))
        (end (progn (forward-paragraph arg) (point))))
    (copy-region-as-kill beg end)))

(global-set-key "\C-cw"         'copy-word)
(global-set-key "\C-cl"         'copy-line)
(global-set-key "\C-cp"         'copy-paragraph)


;; Make C-w, M-w work on word if no selection
(set-key-lambda "\C-w" (call-interactively
                        (if (use-region-p) 'kill-region 'kill-word)))
(set-key-lambda "\M-w"
                (if (use-region-p)
                    (call-interactively 'kill-ring-save)
                  (kill-ring-save (point) (progn (forward-word 1) (point)))
                  (setq this-command 'kill-region)))

;; C-S-w, M-S-w, C-S-y -- works on registers
(defvar copy-or-append-to-register--register nil)

(defun copy-or-append-to-register (register start end &optional delete append)
  (interactive
   (let ((append-p (equal last-command this-command)))
     (list
      (or (and append-p copy-or-append-to-register--register)
          (read-char (if append-p
                       "Append to register: " "Copy to register: ") nil nil))
      (if (use-region-p) (region-beginning) (point))
      (if (use-region-p) (region-end) (progn (forward-word 1) (point)))
      prefix-arg
      append-p)))
  (if append
      (append-to-register register start end delete)
    (copy-or-append-to-register register start end delete))
  (setq copy-or-append-to-register--register register))

(defun kill-or-append-to-register ()
  (setq prefix-arg t)
  (call-interactively 'copy-or-append-to-register))

(global-set-key [(control shift w)] 'copy-or-append-to-register)
(global-set-key [(meta    shift w)] 'kill-or-append-to-register)
(global-set-key [(control shift y)] 'insert-register)

;;}}}

;;}}}
;;{{{ Syntax highlighting

;; Font lock
(require 'font-lock)
(global-font-lock-mode t)
(setq font-lock-verbose nil)          ;no messages

;; Let customize keep config there
(setq custom-file (concat user-emacs-directory "custom"))
(if (file-exists-p custom-file) (load-file custom-file))
(if (boundp 'auto-byte-compile-files-list)
    (setq auto-byte-compile-files-list
          (cons custom-file auto-byte-compile-files-list)))

;; Other
(setq query-replace-highlight t)  ;highlight during query
(setq search-highlight t)         ;highlight incremental search
(show-paren-mode t)               ;show matching parenthesis.
(setq blink-matching-paren-distance nil) ;search for open-paren till point-min

;;{{{ Set faces

;; Code based on color-theme but simplified
(dolist
    (entry
     '((default
         (t (:stipple nil
             :background "black"
             :foreground "#CCC"
             :inverse-video nil
             :box nil
             :strike-through nil
             :overline nil
             :underline nil
             :slant normal
             :weight normal
             :height 80
             :width normal
             :family "courier"
             :foundry "adobe")))

       (region
        (((type x-toolkit)) (:foreground nil :background "blue"))
        (t (:foreground nil :background nil :inverse-video t)))
       (secondary-selection
        (((type x-toolkit)) (:foreground nil :background "SkyBlue4"))
        (t (:foreground nil :background nil :inverse-video t)))
       (tooltip
        (t (:inherit variable-pitch :background "lightyellow" :foreground "black")))

       (completions-common-part
        (t (:inherit default :foreground "yellow")))
       (completions-first-difference
        (t (:inherit default :foreground "cyan" :weight bold)))

       (custom-button
        (t (:foreground "cyan")))
       (custom-button-face
        (t (:foreground "cyan")))
       (custom-documentation
        (t (:foreground "yellow" :weight bold)))
       (custom-documentation-face
        (t (:foreground "yellow" :weight bold)))
       (custom-group-tag
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-group-tag-face
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-variable-tag
        (t (:foreground "cyan" :underline t :weight bold)))
       (custom-variable-tag-face
        (t (:foreground "cyan" :underline t :weight bold)))

       (diff-added
        (t (:inherit diff-changed :foreground "green")))
       (diff-added-face
        (t (:foreground "green" :weight bold)))
       (diff-changed
        (t (:foreground "yellow")))
       (diff-changed-face
        (t (:foreground "yellow" :weight bold)))
       (diff-indicator-added
        (t (:inherit diff-added)))
       (diff-removed
        (t (:inherit diff-changed :foreground "red")))
       (diff-removed-face
        (t (:foreground "red" :weight bold)))

       (font-lock-builtin-face
        (t (:foreground "#99F")))
       (font-lock-comment-face
        (t (:foreground "green" :slant italic)))
       (font-lock-constant-face
        (t (:foreground "aquamarine")))
       (font-lock-doc-face
        (t (:inherit font-lock-comment-face :foreground "#CF0")))
       (font-lock-function-name-face
        (t (:foreground "lightskyblue")))
       (font-lock-keyword-face
        (t (:foreground "#0FF")))
       (font-lock-negation-char-face
        (t nil))
       (font-lock-string-face
        (t (:foreground "lightsalmon")))
       (font-lock-type-face
        (t (:foreground "palegreen")))
       (font-lock-variable-name-face
        (t (:foreground "lightgoldenrod")))
       (font-lock-warning-face
        (t (:foreground "pink" :weight bold)))
       (fringe
        (t (:background "#002")))
       (header-line
        (t (:inherit mode-line :background "#006" :foreground "#FFF" :box nil)))
       (help-argument-name
        (t (:inherit font-lock-variable-name-face)))
       (highlight
        (t (:background "#060" :underline "#0F0")))
       (hl-line
        (t (:background "#003")))
       (lazy-highlight
        (t (:background "paleturquoise4")))
       (link
        (t (:foreground "cyan" :underline t)))
       (link-visited
        (t (:inherit link :foreground "#96F")))
       (match
        (t (:background "RoyalBlue3")))

       (mode-line
        (t (:background "#009" :foreground "white" :box nil)))
       (mode-line-buffer-id
        (t (:foreground "#9FF" :weight bold)))
       (mode-line-highlight
        (t (:background "#00F")))
       (mode-line-inactive
        (t (:inherit mode-line :box nil :background nil :foreground "#CCC")))

       (widget-button
        (t (:background "blue" :foreground "cyan" :weight bold)))
       (widget-button-face
        (t (:background "blue" :foreground "cyan" :weight bold)))
       (widget-field
        (t (:background "blue")))
       (widget-field-face
        (t (:background "blue")))

       (my-tab-face
        (((class color) (min-colors 216)) (:background "#666"))
        (t (:background "yellow")))
       (my-big-indent-face
        (((class color) (min-colors 216)) (:background "#966"))
        (t (:background "red")))
       (my-huge-indent-face
        (((class color) (min-colors 216)) (:background "#C66"))
        (t (:background "magenta")))
       (my-fixme-face
        (t :background "red" :foreground "white" :weight bold))
       (my-todo-face
        (t :foreground "red" :weight bold))))
  (let ((face (car entry)) (spec (cdr entry)))
    (unless (facep face)
      (make-empty-face face))
    (condition-case var
        (progn
          (put face 'face-override-spec spec)
          (face-spec-set face spec))
      (error (message "Error using spec %S: %S" spec var)))))

;;}}}

;; Show blanks and FIXME
;; http://www.emacswiki.org/cgi-bin/wiki/EightyColumnRule
(add-hook 'font-lock-mode-hook (function (lambda ()
  (unless (or (eq 'diff-mode major-mode) (eq 'script-mode major-mode))
    (font-lock-add-keywords nil
     '(("\t+" 0 'my-tab-face t)
       ("^\t\\{4,5\\}" 0 'my-big-indent-face t)
       ("^\t\\{6,\\}" 0 'my-huge-indent-face t)
       ("\\<\\(TODO:?\\)\\>" 1 'my-todo-face t)
       ("\\<\\(FIXME:?\\|XXX\\)\\>" 1 'my-fixme-face t)))))))

;;}}}
;;{{{ Misc small config

(setq use-dialog-box nil)         ;never use dialog boxes

;; Frame apperence
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(if (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(let ((fringe
       (if (eval-when-compile (string-match "^erwin" system-name)) 7 4)))
  (setq default-frame-alist `((width . 80)
                              (right-fringe . ,fringe)
                              (left-fringe  . ,fringe)
                              (menu-bar-lines . 0)
                              (tool-bar-lines . 0)
                              (vertical-scroll-bars)
                              (foreground-color . "gray")
                              (background-color . "black")
                              (background-mode . dark))))

;; Modeline
(setq line-number-mode t          ;show line number in modeline
      column-number-mode t)       ;show column number in modeline

(setq mode-line-format
      '("%e"
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        mode-line-buffer-identification
        "  "
        mode-line-position
        vc-mode
        " "
        mode-line-modes
        (which-func-mode ("" which-func-format))
        (global-mode-string ("" global-mode-string))
        "%-")

      mode-line-position
      '(:eval (let* ((min (point-min)) (max (point-max))
                     (wide (and (= min 1) (= max (1+ (buffer-size))))))
                (concat
                 (if wide "(" "[")
                 (if column-number-mode "%2c, " "")
                 (if line-number-mode "%2l/" "")
                 (number-to-string (1+ (count-lines min max)))
                 (if wide ")" "]"))))

      mode-line-modes
      '("("
        (:propertize
         ("" mode-name mode-line-process minor-mode-alist)
         help-echo "mouse-1: major mode, mouse-2: major mode help, mouse-3: toggle minor modes"
         mouse-face mode-line-highlight
         local-map (keymap
                    (header-line keymap
                                 (down-mouse-3 . mode-line-mode-menu-1))
                    (mode-line keymap
                               (down-mouse-3 . mode-line-mode-menu-1)
                               (mouse-2 . describe-mode)
                               (down-mouse-1 . mouse-major-mode-menu))))
        ") "))


;; Other
(icomplete-mode 1)                ;nicer completion in minibuffer
(setq icomplete-prospects-height 2) ; don't spam my minibuffer
(define-key minibuffer-local-map "\C-c"  ; C-c clears minibuffer
  (lambda () (interactive) (delete-minibuffer-contents)))
(setq suggest-key-bindings 3)     ;suggestions for shortcut keys for 3 seconds
(setq frame-title-format "Emacs") ;frame title format
(setq history-delete-duplicates t)
(setq inhibit-splash-screen   t   ;don't show splash screen
      inhibit-startup-echo-area-message "mina86" ;don't show "For info..." message
      inhibit-startup-buffer-menu t) ;don't show buffer menu when oppening
                                  ; many files               (EMACS 21.4+)
(setq sentence-end-double-space 1 ;sentance end with double space
      require-final-newline t)    ;always end file with NL
(setq truncate-lines nil)         ;wrap lines
(fset 'yes-or-no-p 'y-or-n-p)     ;make yes/no be y/n
(set-default 'indicate-empty-lines t) ;show empty lines at the end of file
(set-default 'indicate-buffer-boundaries t) ;show buffer boundries on fringe
(setq x-alt-keysym 'meta)         ;treat Alt as Meta even if real Meta found
(setq gc-cons-threshold 4000000)  ;bytes before garbage collection
(setq ange-ftp-try-passive-mode t);passive FTP
;(setq ange-ftp-ftp-program-name "pftp") ;passive FTP
(blink-cursor-mode nil)           ;do not blink cursor
;(setq mouse-autoselect-window nil)  ;focus follows mouse
(when (boundp 'compilation-auto-jump-to-first-error)
  (setq compilation-auto-jump-to-first-error t))
(when (boundp 'line-move-visual)
  (setq line-move-visual nil))  ;move by logical lines not screen lines

;; Saving etc
(when (fboundp recentf-mode)
  (recentf-mode nil))           ;no recent files
(setq backup-by-copying-when-linked t) ;preserve hard links
(auto-compression-mode 1)         ;automatic compression
(setq make-backup-files nil)      ;no backup
;(global-auto-revert-mode 1)       ;automaticly reload buffer when changed
                                  ; it makes all folds unfload :(
                                  ; and what's worse - sux with ftp


;; Indention
(defmacro set-tab-stop-list (width)
  "Sets `tab-stop-list' to a list of all positive from smallest to
largest which are multiplications of WIDTH and are lower or equal 120.
WIDTH must be a literal number because this macro evaluates the list
during expansion."
  (let* ((w width) (n (/ 120 w)) l)
    (while (> (setq l (cons (* n w) l) n (1- n)) 0))
    `(setq tab-stop-list ',l)))

(setq indent-tabs-mode t)         ;indent using tabs
(setq tab-width 4)                ;tab width
(set-tab-stop-list 4)
;; One could add this to check if tab-width and c-basic-offset correspond
;(if (not (= 0 (% c-basic-offset tab-width)))
;    (warn "`tab-width' does not divide `c-basic-offset'"))


;; Regions, selections and marks
(setq mouse-yank-at-point t)      ;mouse yank at point not at cursor   (X-win)
(setq kill-read-only-ok t)        ;be silent when killing text from RO buffer
(delete-selection-mode 1)         ;deleting region by typing or del (like Win)
(setq transient-mark-mode t)
(setq set-mark-command-repeat-pop t)


;; Scrolling/moving
(setq scroll-step 1)              ;scroll one line
;(setq scroll-preserve-screen-position t) ;keep point's position on screen
(setq hscroll-step 1)             ;scroll one column
(setq next-line-add-newlines nil) ;no new lines with down arrow key


;; Blink Scroll Lock LED instead of beep
(setq visible-bell nil)           ;no visual bell
(setq ring-bell-function (function (lambda ()
  (call-process-shell-command "xset led 3; xset -led 3" nil 0 nil))))


;; Each list element as new paragraph
;; http://www.emacswiki.org/cgi-bin/wiki/FillParagraph
(setq paragraph-start    " *\\([*+-]\\|\\([0-9]+\\|[a-zA-Z]\\)[.)]\\|$\\)"
      paragraph-separate "$")


;; GDB
(setq gdb-many-windows t
      gdb-show-main t
      gdb-use-separate-io-buffer nil)


;; Do not break line after single character when filling
(defun fill-single-char-nobreak-p ()
  "Don't break line after a single character."
  (save-excursion
    (skip-chars-backward " \t")
    (backward-char 2)
    (looking-at "[[:space:]][a-zA-Z]")))

(add-to-list 'fill-nobreak-predicate 'fill-single-char-nobreak-p)


;; Sort words in region
;; http://www.emacswiki.org/emacs/SortWords
(defun sort-words (reverse beg end)
  "Sort words in region alphabetically, in REVERSE if negative.
Prefixed with negative \\[universal-argument], sorts in reverse.
The variable `sort-fold-case' determines whether alphabetic case
affects the sort order.
See `sort-regexp-fields'."
  (interactive "P\nr")
  (sort-regexp-fields reverse "\\w+" "\\&" beg end))

;;}}}
;;{{{ Major Modes

;;{{{   CC Mode

(eval-after-load "compile"
  (progn
    (c-add-style
     "mina86"
     '((c-basic-offset . 4)             ; 4-char wide indention...
       (tab-width . 4)                  ; ...which equals single tab...
       (indent-tabs-mode . t)           ; ...so use tabs
       (c-comment-only-line-offset . 0)  ; XXX no idea what it does
       (c-label-minimum-indentation . 1) ; no min. indention for labels

       (c-cleanup-list                 ; Clean ups
        brace-else-brace                 ; "} else {" in one line
        brace-elseif-brace               ; "} else if (...) {" in one line
        brace-catch-brace                ; "} catch (...) {" in one line
        defun-close-semi                 ; "};" together
        )

       (c-offsets-alist                ; Indention levels:
        ; Don't indent inside namespaces, extern, etc
        (incomposition          . 0)
        (inextern-lang          . 0)
        (inmodule               . 0)
        (innamespace            . 0)

        ; Preprocessor macros
        (cpp-define-intro       c-lineup-cpp-define +)
        (cpp-macro              . [ 0 ])
        (cpp-macro-cont         . +)

        ; Brace after newline newer indents
        (block-open             . 0)
        (brace-entry-open       . 0)
        (brace-list-open        . 0)
        (class-open             . 0)
        (composition-open       . 0)
        (defun-open             . 0)
        (extern-lang-open       . 0)
        (inline-open            . 0)
        (module-open            . 0)
        (namespace-open         . 0)
        (statement-case-open    . 0)
        (substatement-open      . 0)

        ; Obviously, do not indent closing brace
        (arglist-close          . 0)
        (block-close            . 0)
        (brace-list-close       . 0)
        (class-close            . 0)
        (composition-close      . 0)
        (defun-close            . 0)
        (extern-lang-close      . 0)
        (inline-close           . 0)
        (module-close           . 0)
        (namespace-close        . 0)

        ; Obviously, indent next line after opening brace and single statements
        (defun-block-intro      . +)
        (statement-block-intro  . +)
        (substatement           . +)

        ; Handle nicely multi line argument lists
        (arglist-close c-lineup-arglist 0)
        (arglist-cont          mn-c-lineup-argcont c-lineup-gcc-asm-reg +)
        (arglist-cont-nonempty mn-c-lineup-argcont c-lineup-gcc-asm-reg c-lineup-arglist +)
        (arglist-intro . c-lineup-arglist-intro-after-paren)

        ; Misc
        (brace-list-intro       . +)     ; Indent elements in brace-lists
        (brace-list-entry       . 0)
        (c      . c-lineup-C-comments)   ; Indent comments nicely
        (comment-intro          . c-lineup-comment)
        (catch-clause           . 0)     ; catch/finally where try
        (do-while-closure       . 0)     ; while (...) where do
        (else-clause            . 0)     ; else where if
        (func-decl-cont         . +)     ; Indent stuff after function
        (friend                 . 0)     ; friend need no additional indention
        (inclass                . +)     ; Indent stuff inside class...
        (access-label           . -)     ; ...expect for access labels
        (inexpr-statement       . 0)     ; No unneeded indent in ({ ... })...
        (inexpr-class           . 0)     ; ...& anonymous classes
        (inher-intro            . +)     ; ndent & lineup inheritance list
        (inher-cont             . c-lineup-multi-inher)
        (member-init-intro      . +)     ; Indent & lineup initialisation list
        (member-init-cont       . c-lineup-multi-inher)
        (label                  . [ 0 ]) ; Labels always on first column
        (substatement-label     . [ 0 ])
        (statement              . 0)     ; Statement same as line above...
        (statement-cont c-lineup-cascaded-calls +) ; ...but indent cont.
        (statement-case-intro   . +)     ; Indent statements in switch...
        (case-label             . 0)     ; ...but not the labels
        (stream-op . c-lineup-streamop)  ; Lineup << operators in C++
        (string . c-lineup-dont-change)  ; Do not touch strings!
        (template-args-cont c-lineup-template-args +) ; Lineup template args
        (topmost-intro          . 0)     ; Topmost stay topmost
        (topmost-intro-cont     c-lineup-topmost-intro-cont 0)

        ; Other stuff I don't really care about
        ; I keep it here for the sake of having all symbols specified.
        (inlambda               . c-lineup-inexpr-block)
        (knr-argdecl            . 0)
        (knr-argdecl-intro      . +)
        (lambda-intro-cont      . +)
        (objc-method-args-cont  . c-lineup-ObjC-method-args)
        (objc-method-call-cont
         ;c-lineup-ObjC-method-call-colons
         c-lineup-ObjC-method-call +)
        (objc-method-intro      . [0])
        )

       ; I don't care about anything that is below -- not using any
       ; automagick -- but for the sake of having everything set I'll keep
       ; it here.

       (c-hanging-braces-alist         ; Auto new lines around braces
        ; In most cases new line after open brace and both before and
        ; after close brace.  The "before" is however ommited
        ; from *-close symbols because when editing normally we will
        ; be on the new line already -- if we're not, user probably
        ; knows better.
        (defun-open             after)
        (defun-close            after)
        (class-open             after)
        (class-close            after)
        (inline-open            after)
        (inline-close           after)
        (extern-lang-open       after)
        (extern-lang-close      after)
        (namespace-open         after)
        (namespace-close        after)
        (module-open            after)
        (module-close           after)
        (composition-open       after)
        (composition-close      after)

        ; No new line after closing brace if it matches do { or if (...) {
        (block-open             after)
        (substatement-open      after)
        (block-close            . c-snug-do-while)

        ; With brace-lists however, do nothing automatically -- user knows
        ; better
        (brace-list-open        )
        (brace-list-close       )
        (brace-list-intro       )
        (brace-entry-open       )

        ; Others
        (statement-cont         )
        (statement-case-open    after)
        (inexpr-class-open      )
        (inexpr-class-close     )
        (arglist-cont-nonempty  )
        )

       (c-hanging-colons-alist
        ; Add new line after labels
        (case-label             after)
        (label                  after)
        (access-label           after)
        ; But nothing else
        (member-init-intro      )
        (inher-intro            )

        (c-hanging-semi&comma-criteria
         (mn-c-semi&comma-no-newlines-if-open-brace
          c-semi&comma-no-newlines-before-nonblanks
          c-semi&comma-inside-parenlist))
        )))

    ; For Linux use 8-char tabs
    (c-add-style
     "mina86-linux"
     '("mina86"
       (c-basic-offset . 8)
       (tab-width . 8)))


    (defun mn-c-semi&comma-no-newlines-if-open-brace ()
      "Prevents newline after semicolon if there is an open brace
on the same line.  Function is a bit stupid and does not check if
the open brace was real open brace or part of comment/string."
      (when (let ((p (point))) (save-excursion (forward-line 0)
                                               (search-forward "{" p t)))
        'stop))

    (defun mn-c-lineup-argcont (elem)
      "Line up a continued argument's operands (assumes there
will be a single space after an operator ifit starts the line).

foo(xyz, aaa +
         bbb               <- c-lineup-argcont
       + ccc               <- c-lineup-argcont
      << ccc               <- c-lineup-argcont
      ==  eee);            <- c-lineup-argcont
if (foo
 || bar)                   <- c-lineup-argcont

Only continuation lines like this are touched, nil is returned on lines
which are the start of an argument.

Within a gcc asm block, \":\" is recognized as an argument separator,
but of course only between operand specifications, not in the expressions
for the operands.

Works with: arglist-cont, arglist-cont-nonempty."
      (let ((ret (c-lineup-argcont elem)))
        (if (and (vectorp ret)
                 (save-excursion
                   (back-to-indentation)
                   (looking-at
                    (eval-when-compile
                      (regexp-opt
                       (list
                        "+" "+=" "++" "-" "-=" "--" "*" "*=" "/" "/=" "%"
                        "%=" "^" "^=" "&" "&=" "&&" "|" "|=" "||" "<<"
                        "<<=" ">>" ">>=" "<" "<=" ">" ">=" "=" "==" ":"
                        "::" "?"))))))
            (vector (- (elt ret 0) (- (match-end 0) (match-beginning 0)) 1))
          ret)))


    (setq c-default-style '((awk-mode . "awk")
                            (other    . "mina86")))

    (add-hook 'c-common-mode-hook
              (lambda ()
                (when buffer-file-name
                  (let ((fn (file-name-nondirectory buffer-file-name)))
                    (set (make-local-variable 'compile-command)
                         (concat "make -k "
                                 (substring
                                  fn 0 (string-match "\\.[^\\.]*$" fn 1))))))))

    (add-hook 'c-mode-hook (lambda ()
                             (when (and buffer-file-name
                                        (string-match "linux" buffer-file-name))
                               (c-set-style "mina86-linux"))))))

;;}}}
;;{{{   HTML/XML & comapny Mode

;; Create a link out of the preceeding word if it appears to be a URL
(if (load "thingatpt" t)
    (defun mn-linkify-maybe ()
      "If the word before cursor appears to be an URL wrap it around
in a <a href=\"...\">...</a>.  Returns whether it happend."
      (interactive "*")
      (when (save-excursion
              (save-restriction
                (let ((end (point)))
                  (beginning-of-line)
                  (narrow-to-region (point) end)
                  (looking-at
                   (concat ".*\\(" thing-at-point-url-regexp "\\)\\'")))))
        (let ((url (delete-and-extract-region (match-beginning 1)
                                              (match-end 1))))
          (insert "<a href=\"" url "\">" url "</a>"))))
  (defun mn-linkify-maybe ()
    "If the word before cursor appears to be an URL wrap it
around in a <a href=\"...\">...</a>.  Returns whether it happend.

This is however a stub implementation (because thingatpt could not be loaded) which does nothing and returns nul."
    nil))


(defun mn-magick-self-insert-command (spec &optional default when-prefix)
  "If prefix argument is not nil calls WHEN-PREFIX with single
argument being a `prefix-numeric-value' or the `prefix-arg'.

Otherwise looks through SPEC which is a list of 3-element
lists (called rules):
  (regexp length action)
Rule is said to match if `point' is at least LENGTH characters from
`point-min' and REGEXP matches starting at position LENGTH characters
earlier then `point'.  ACTION of first rule that matches is performed.
If no rule matches DEFAULT is treated as action to perform.

If ACTION to perform is a string (DEFAULT may not be a string)
then `replace-match' is called otherwise it is assumed ACTION is
a function and it is called with single argument 1.

DEFAUTL and WHEN-PREFIX defaults to `self-insert-command'."
  (if prefix-arg
      (funcall (or when-prefix  'self-insert-command)
               (prefix-numeric-value prefix-arg))
    (let ((action (catch 'done
                    (let ((dist (- (point) (point-min))))
                      (dolist (rule spec)
                        (when (>= dist (cadr rule))
                          (save-excursion
                            (backward-char (cadr rule))
                            (when (looking-at (car rule))
                              (throw 'done (cadr (cdr rule))))))))
                    default)))
      (if (stringp action) (replace-match action)
        (funcall (or action 'self-insert-command) 1)))))

(defmacro mn-magick-self-insert-define
  (map key spec &optional default when-prefix)
  `(define-key ,map ,key
     (lambda () (interactive ,"*")
       (mn-magick-self-insert-command ,spec ,default ,when-prefix))))

(defun mn-xml-configure-bindings (mode-map)
  (mn-magick-self-insert-define mode-map " "
                                '(("[^<]\\b\\w" 2 "\\&&#160;")
                                  ("^\\w"       1 "\\&&#160;")
                                  ("&#160;"     6 " "))
                                (lambda (n)
                                  (mn-linkify-maybe)
                                  (self-insert-command n)))
  (mn-magick-self-insert-define mode-map "<"
                                '(("<"          1 "&lt;")
                                  ("&lt;"       4 "&#xab;")))
  (mn-magick-self-insert-define mode-map ">"
                                '(("&#160;&#8211;" 13 " -->")
                                  (">"          1 "&gt;")
                                  ("&gt;"       4 "&#xbb;")))
  (mn-magick-self-insert-define mode-map "&"
                                '(("&"          1 "&amp;")))
  (mn-magick-self-insert-define mode-map "."
                                '(("\\.\\."     2 "&#8230;")))
  (mn-magick-self-insert-define mode-map "\""
                                '(("\""         1 "&quot;")))
  (mn-magick-self-insert-define mode-map "~"
                                '(("~"          1 "&#160;")))
  (mn-magick-self-insert-define mode-map "'"
                                '(("'"          1 "&#8221;")))
  (mn-magick-self-insert-define mode-map "`"
                                '(("`"          1 "&#8220;")))
  (mn-magick-self-insert-define mode-map ","
                                '((","          1 "&#8222;")))
  (mn-magick-self-insert-define mode-map "."
                                '(("\\.\\."     2 "&#8230;")))
  (mn-magick-self-insert-define mode-map "-"
                                '(("[-!]-"      2 nil)
                                  (" -"         2 "&#160;&#8211;")
                                  ("-"          1 "&#160;&#8211;")
                                  ("&#8211;"    7 "&#8212;")
                                  ("\\\\"       1 "&8209;")))
  ;; (mn-magick-self-insert-define mode-map "/"
  ;;                               '(("<"          1
  ;;                                  (lambda (n)
  ;;                                    (backward-delete-char 1)
  ;;                                    (sgml-close-tag)))))
  (mn-magick-self-insert-define mode-map [(backspace)]
                                '(("&lt;"       4 "<")
                                  ("&#xab;"     6 "&lt;")
                                  ("&gt;"       4 ">")
                                  ("&#xbb;"     6 "&gt;")
                                  ("&amp;"      5 "&")
                                  ("&quot;"     6 "\"")
                                  ("&#8230;"    7 "..")
                                  ("&#8220;"    7 "`")
                                  ("&#8221;"    7 "'")
                                  ("&#8222;"    7 ",")
                                  ("&#8212;"    7 "&#8211;")
                                  ("&#82\\(?:11\\|09\\);" 7 "-")
                                  ("&.....;"    7 "")
                                  ("&....;"     6 "")
                                  ("&...;"      5 "")
                                  ("&..;"       4 ""))
                                'delete-backward-char
                                'delete-backward-char)
  (setq indent-tabs-mode ()))

(eval-when-compile (require 'sgml-mode))
(eval-after-load "sgml-mode"
  (add-hook 'sgml-mode-hook
            (lambda () (mn-xml-configure-bindings sgml-mode-map))))

(when (fboundp 'nxml-mode)
  (eval-when-compile (require 'nxml-mode))
  (add-to-list 'auto-mode-alist '("\\.\\(?:x\\|ht\\)ml\\'" . nxml-mode))
  (eval-after-load "nxml-mode"
    (add-hook 'nxml-mode-hook
              (lambda () (mn-xml-configure-bindings nxml-mode-map)))))




(defun replace-string-pairs (list)
  (let* ((mark  (use-region-p))
         (start (if mark (region-beginning) (point)))
         (end   (if mark (region-end) (point-max))))
    (save-excursion
      (dolist (pair list)
        (let ((diff (- (length (cdr pair)) (length (car pair)))))
          (goto-char start)
          (while (search-forward (car pair) end t)
            (setq end (+ end diff))
            (replace-match (cdr pair) nil t)))))))

(defun html-escape ()
  "Replaces HTML special characters with HTML entities.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer."
  (interactive)
  (replace-string-pairs
   '(("&" . "&amp;") ("<" . "&lt;") (">" . "&gt;") ("\"" . "&quot;"))))

(defun html-unescape ()
  "Replaces (some) HTML entities with characters.

In Transient Mark mode, if the mark is active, operate on the contents
of the region.  Otherwise, operate from point to the end of the buffer."
  (interactive)
  (replace-string-pairs
   '(("&amp;" . "&") ("&lt;" . "<") ("&gt;" . ">") ("&quot;" . "\""))))

;;}}}
;;{{{   (La)TeX and nroff mode

;; Helper for tex-space
(defmacro my-tex-looking-back (regexp len)
  "Returns non-nil if text LEN chars backward matches REGEXP
prefixed with \\b."
  `(save-excursion
     (backward-char ,len)
     (looking-at ,(concat "\\b" regexp))))

;; insert '~' or '\ ' instead of ' ' in LaTeX when needed
;; Also removes '~' when 2nd space added
;; http://www.debianusers.pl/article.php?aid=39
(defun tex-space (arg) (interactive "P")
  (cond
   ((re-search-backward "\\~" (- (point) 1) t)
    (delete-char 1) (self-insert-command (prefix-numeric-value arg)))
   (arg (self-insert-command (prefix-numeric-value arg)))
   ((my-tex-looking-back "[a-z]" 1)
    ;    (my-tex-looking-back "[a-z][a-z]" 2))
    (insert-char ?~ 1))
   ((or (my-tex-looking-back "[a-z][a-z]\\." 3)
        (my-tex-looking-back "\\(?:tz[wn]\\|it[pd]\\)\\." 4))
    (insert "\\ "))
   (t (self-insert-command 1))))

(eval-when-compile (require 'tex-mode))
(add-hook 'tex-mode-hook
          (function (lambda () (define-key tex-mode-map " " 'tex-space))))
(add-hook 'latex-mode-hook
          (function (lambda () (define-key tex-mode-map " " 'tex-space))))


;; Insert '\ ' instead of ' ' in nroff when needed
;; Also removes '\' when 2nd space added
(defun nroff-space (arg) (interactive "p")
  (cond
   ((re-search-backward "\\\\ " (- (point) 2) t)
    (delete-char 1) (forward-char) (self-insert-command arg))
   ((> arg 1) (self-insert-command arg))
   ((my-tex-looking-back "[a-z]" 1)
;        (my-tex-looking-back "[a-z][a-z]" 2))
;        (my-tex-search-back "do\\|na\\|od\\|po\\|za\\|we\\|to\\|co" 2))
    (insert-char ?\\ 1) (self-insert-command 1))
   (t (self-insert-command 1))))

(eval-when-compile (require 'nroff-mode))

(add-hook 'nroff-mode-hook
          (function (lambda () (define-key nroff-mode-map " " 'nroff-space))))

;;}}}
;;{{{   Generate serialVersionUID in Java

(defun mn-serialVersionUID (&optional insert)
  "When called interactivly or with a non nil argument inserts
a random 64-bit hexadecimal integer prefixed with \"0x\" and
suffixed with \"L\".  When called with nil argument or with
argument ommited returns that number."
  (interactive (list t))
  (if insert
      (insert (mn-serialVersionUID))
    (format "0x%04x%04x%04x%04xL"
            (random 65536) (random 65536)
            (random 65536) (random 65536))))

(add-hook 'java-mode-hook (lambda ()
  (add-hook 'write-contents-functions (lambda ()
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (while (re-search-forward "serialVersionUID\s+=\s+[0-9a-fA-FxX]+L;"
                                  nil t)
          (replace-match
           (concat "serialVersionUID = " (mn-serialVersionUID) ";")
           nil t))))))))

;;}}}
;;{{{   Misc

;; Text mode
(add-hook 'text-mode-hook (function (lambda ()
    (auto-fill-mode t)
    (setq tab-width 8)
    (set-tab-stop-list 8))))


;; Assembler mode
(add-hook 'asm-mode-hook (function (lambda ()
    (setq tab-width 8)
    (set-tab-stop-list 16)
    (setq comment-column 40))))


;; Org mode
(setq org-insert-mode-line-in-empty-file t)

;; PHP mode
;; http://sourceforge.net/projects/php-mode
(autoload 'php-mode "php-mode" "PHP editing mode" t)
(add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode))


;; JavaScript mode
(unless (fboundp 'js2-mode)
  (add-to-list 'auto-mode-alist '("\\.js\\'" . c-mode)))


;; Shell mode
;; This prevents shell commands from being echoed
(eval-when-compile (require 'shell))
(add-hook 'comint-mode-hook (function (lambda ()
  (setq comint-process-echoes t))))


;; Lisp/Scheme mode
;; No tabs! and if opening file with tabs, assume 8-char wide
(let ((func (function (lambda () (setq indent-tabs-mode () tab-width 8)))))
  (add-hook 'emacs-lisp-mode-hook func)
  (add-hook 'lisp-mode-hook       func)
  (add-hook 'scheme-mode-hook     func))


;; Sawfish mode
(autoload 'sawfish-mode "sawfish" "Mode for editing Sawfish config files")
(add-to-list 'auto-mode-alist '(".*sawfishrc\\'" . sawfish-mode))
(add-to-list 'auto-mode-alist '(".*\\.jl\\'" . sawfish-mode))


;; Bison mode
(autoload 'bison-mode "bison-mode.el")
(add-to-list 'auto-mode-alist '("\\.y$" . bison-mode))
(setq bison-decl-type-column   8)
(setq bison-decl-token-column 16)


;; Flex
(autoload 'flex-mode "flex-mode")
(add-to-list 'auto-mode-alist '("\\.l$" . flex-mode))


;; LSL mode
(autoload 'lsl-mode "lsl-mode" "Load LSL mode." t)
(add-to-list 'auto-mode-alist '("\\.lsl$" . lsl-mode))
(add-hook 'lsl-mode-hook (function (lambda nil (setq indent-tabs-mode nil))))


;; Haskell mode
(when (eval-when-compile
        (file-directory-p (concat user-emacs-directory "elisp/haskell-mode")))
  (setq load-path (cons (concat user-emacs-directory "elisp/haskell-mode") load-path))
;  (require 'haskell-indentation)
  (autoload 'haskell-mode "haskell-mode" "Load Haskell mode." t)
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation))

;;}}}

;;}}}
;;{{{ Various features

;;{{{   HTMLize

;; http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el
(autoload 'htmlize-buffer "htmlize" "Convert buffer to HTML" t)
(autoload 'htmlize-region "htmlize" "Convert region to HTML" t)

;;}}}
;;{{{   Folding

(when (load "folding")
  (defconst folding-default-keys-function
    '(folding-bind-backward-compatible-keys))

  (define-key folding-mode-map "\C-cf"         'folding-toggle-show-hide)
  (define-key folding-mode-map [(control ?c) (return)] 'folding-shift-in)
  (define-key folding-mode-map [(control ?c) (delete)] 'folding-shift-out)
  (define-key folding-mode-map [(control ?c) (backspace)] 'folding-shift-out)
  (define-key folding-mode-map "\C-c\C-f"      'folding-open-buffer)
  (define-key folding-mode-map "\C-cF"         'folding-whole-buffer)
  (define-key folding-mode-map "\C-e"          'my-end)

  (folding-add-to-marks-list 'php-mode        "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'sawfish-mode    ";;{{{" ";;}}}" nil t)
  (folding-add-to-marks-list 'javascript-mode "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'css-mode        "/* {{{" "/* }}}" " */" t)

  (folding-mode-add-find-file-hook))

;;}}}
;;{{{   Different cursor color depending on mode

;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar hcz-set-cursor-color-color "")
(defvar hcz-set-cursor-color-buffer "")
(defun hcz-set-cursor-color-according-to-mode ()
  "Change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color (cond (buffer-read-only "blue")
                     (overwrite-mode "red")
                     (t "yellow"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)

(set-cursor-color (setq hcz-set-cursor-color-color "yellow"))

;;}}}
;;{{{   Notes in *scratch*

;; Notes in *scratch*  v. 0.2
;; Copyright (c) 2006 by Michal Nazarewicz (mina86@mina86.com)
;; Released under GNU GPL

(defconst scratch-file (concat user-emacs-directory "scratch")
  "File where content of *scratch* buffer will be read from and saved to.")
(defconst scratch-file-autosave (concat scratch-file ".autosave")
  "File where to autosave content of *scratch* buffer.")

(save-excursion
  (set-buffer (get-buffer-create "*scratch*"))
  (if (file-readable-p scratch-file)
      (if (and (file-readable-p scratch-file-autosave)
               (file-newer-than-file-p scratch-file-autosave scratch-file))
;               (y-or-n-p "Recover scratch file? "))
          (insert-file-contents scratch-file-autosave nil nil nil t)
        (insert-file-contents scratch-file nil nil nil t)
        (set-buffer-modified-p nil)))
  (auto-save-mode 1)
  (setq buffer-auto-save-file-name scratch-file-autosave)
  (set (make-local-variable 'revert-buffer-function) 'scratch-revert)
  (fundamental-mode))

(defun scratch-revert (ignore-auto noconfirm)
  (when (file-readable-p scratch-file)
    (insert-file-contents scratch-file nil nil nil t)
    (set-buffer-modified-p nil)))

(defun kill-scratch-buffer ()
  (not (when (string-equal (buffer-name (current-buffer)) "*scratch*")
         (delete-region (point-min) (point-max))
         (set-buffer-modified-p nil)
         (next-buffer)
         t)))

(defun kill-emacs-scratch-save ()
  (save-excursion
    (set-buffer (get-buffer-create "*scratch*"))
    (write-region nil nil scratch-file)
    (unless (string-equal scratch-file buffer-auto-save-file-name)
      (delete-auto-save-file-if-necessary t))))

(add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
(add-hook 'kill-emacs-hook 'kill-emacs-scratch-save)

;;}}}
;;{{{   MLDonkey

; Slackware - the best operating system
; MLDonkey - the best way to download Slackware DVD's
; Emacs - the only editor that supports MLDonkey
; Need more proof Emacs is the best? ;)
(autoload 'mldonkey "mldonkey" "MLDonkey control interface" t)

;;}}}

;; Start server
(unless (and (fboundp 'daemonp) (daemonp))
  (server-start))

(random t)

;;}}}

;; Clear messages
;; You may want to comment it out for debuging
(setq message-log-max nil)        ;disable messages
(kill-buffer "*Messages*")        ;kill buffer with messages
