;;                           -*- mode: emacs-lisp; indent-tabs-mode: nil -*-
;; .emacs  -- Emacs configuration file
;; Copyright 2004-2007 by Michal Nazarewicz (mina86@mina86.com)
;; $Id: dot-emacs,v 1.11 2007/08/08 13:29:50 mina86 Exp $
;;
;;{{{ System dependend data and directories

;; Gnus
(when (file-directory-p "~/.gnus")
  (setq gnus-home-directory (expand-file-name "~/.gnus")
        load-path (cons (concat gnus-home-directory "/gnus/lisp") load-path)
        message-directory (concat gnus-home-directory "/Mail"))
  (eval-after-load "info"
    '(if (load "gnus-load")
         (setq Info-default-directory-list
               (cons (concat gnus-home-directory "/gnus/texi")
                     Info-default-directory-list)))))

;; Add  ~/.emacs.d/elisp  to load path
(if (file-directory-p (expand-file-name "~/.emacs.d/elisp"))
    (setq load-path (cons (expand-file-name "~/.emacs.d/elisp") load-path)))

;; Use  aspell
(setq-default ispell-program-name "aspell")

;;}}}
;;{{{ Auto-byte-compile

(require 'bytecomp)

(defvar auto-byte-compile-files-list
  (let ((ghd (or (and (boundp 'gnus-home-directory) gnus-home-directory)
                 (expand-file-name "~"))))
    (cond
     ((string-match "\\.elc$" user-init-file)
      (list (substring user-init-file 0 -4)
            (substring user-init-file 0 -1)
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))
     (t
      (list user-init-file
            (concat ghd "/.gnus")
            (concat ghd "/.gnus.el")))))
  "List of files to auto compile")

(defun auto-byte-compile-file (&optional file match regexp)
  "file can be
- nil in which case value returned by `buffer-file-name' will be used
  unless it returns nil in which case no action will be taken;
- a string which is equivalent to passing list with that string as the
  only element;
- a list of strings representing file names; or
- anything else which is equivalent to passing
  `auto-byte-compile-files-list'.

Entries equal to \".\", \"..\" or ending with \"/.\" or \"/..\"
are ignored.  If element is a directory it will be processed
recursively but if regexp is nil only files ending with \".el\"
will be processed.

match can be
- nil which is equivalent to passing `auto-byte-compile-files-list';
- a string which is equivalent to passing list with that string as the
  only element;
- a list in which case file have to be in that list to be processed; or
- anything else in which case file will be processed regardless of name.

If any element of match is a string ending with a slash ('/') it
is treated as directory name (no checking is done if it is really
a directory or even if it exists) and file is said to match such
entry if it begins with it thus all files in given directory will
match.

If called interacivelly without prefix arg will behave as with
match equal t.  With prefix arg will behave as with match equal
nil.

regexp must be nil which is equivalent with passing a list
containing only empty string or a list of regular expressions
which file have to match to be processed.

So the default is to auto-compile the current file iff it exists
in `auto-byte-compile-files-list'.

Non-string elements in list will be ignored.

Auto-compilation means that file will be byte-compiled iff the
compiled version does not exits or is older then the file
itself."
  (interactive (list (read-file-name "Auto byte compile file:" nil nil t)
                     (not current-prefix-arg)))

  (if (not (or file (setq file (buffer-file-name))))
      0
    (setq file  (cond ((stringp file)  (list file))
                      ((listp   file)  file)
                      (t               auto-byte-compile-files-list))
          match (mapcar (function (lambda (i) (expand-file-name i)))
                        (cond ((not match)     auto-byte-compile-files-list)
                              ((stringp match) (list match))
                              ((listp match)   match)
                              (t               nil))))

    (let (f (n 0))
      (while (setq f (car file))
        (setq file (cdr file) f (expand-file-name f))
        (cond
         ((string-match f "\\(^\\|/\\)\\.\\.?$"))
         ((file-directory-p f)
          (if regexp
              (setq file (append (directory-files f t nil t) file))
            (setq n (+ n (auto-byte-compile-file (directory-files f t nil t)
                                                 (or match t) '("\\.el$"))))))
         ((and (file-newer-than-file-p f (byte-compile-dest-file f))
               (or (not match)
                   (catch 'found
                     (dolist (m match)
                       (if (string= m (if (string-match "/$" m)
                                          (substring f 0 (length m)) f))
                           (throw 'found t)))))
               (or (not regexp)
                   (catch 'found (dolist (r regexp)
                                   (if (string-match r f) (throw 'found t)))))
               (byte-compile-file f)
               (setq n (1+ n))))))
      n)))

(defun auto-byte-compile-buffer (&optional match buffer)
  "Auto compiles file in given buffer (if buffer is nil current
buffer is used) providing that major mode of the buffer is
lisp-mode or emacs-lisp-mode.  match has the same meaning as in
`auto-byte-compile-file'.

If called interacivelly will behave as with match equal t and
buffer equal nil unless prefix argument was given in which case
match will equal nil."
  (interactive (list (not current-prefix-arg) nil))
  (and (buffer-file-name buffer)
       (memq (if buffer (save-current-buffer (set-buffer buffer)
                                             major-mode) major-mode)
               '(lisp-mode emacs-lisp-mode))
       (auto-byte-compile-file (buffer-file-name buffer) match)))


(add-hook 'kill-buffer-hook 'auto-byte-compile-buffer)
(add-hook 'kill-emacs-hook (function (lambda () (auto-byte-compile-file t))))

;;}}}
;;{{{ Bindings

(defmacro set-key-lambda (key &rest body)
  `(global-set-key ,key (function (lambda () (interactive) ,@body))))

;;{{{   Sequence commands

;; Sequence commands  1.3  by me, Michal Nazarewicz ;)
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
(defvar seq-times 0
  "Stores number of times command was executed.  It cotnains
random data before `seq-times' macro is called.")


(defmacro seq-times (&optional name max &rest body)
  "Returns number of times command NAME was executed and updates
`seq-times' variable accordingly.  If NAME is nil `this-command'
will be used.  If MAX is specified the counter will wrap around
at the value of MAX never reaching it.  If body is given it will
be evaluated if the command is run for the first time in a
sequence."
  (declare (indent 2))

  ;; Build incrementation part
  (setq max (cond ((null max) '(setq seq-times (1+ seq-times)))
                  ((atom max) (if (and (integerp max) (> max 0))
                                  `(setq seq-times (% (1+ seq-times) ,max))
                                '(setq seq-times (1+ seq-times))))
                  (t          `(let ((max ,max))
                                 (if (and (integerp max) (> max 0))
                                     (setq seq-times (% (1+ seq-times) max))
                                   (setq seq-times (1+ seq-times)))))))

  ;; Make macro
  (if (eq name 'last-command)
      max
    (cond ((null  name) (setq name 'this-command))
          ((consp name) (setq name `(or ,name this-command))))
    `(if (eq last-command ,name)
         ,max
       ,@body
       (setq seq-times 0))))


(defmacro seq-times-nth (name body &rest list)
  "Calls `seq-times' with arguments NAME, length and BODY
and (where length is the number of elements in LIST) then returns
`seq-times'th element of LIST."
  (declare (indent 2))
  `(nth (seq-times ,name ,(length list) ,body) ',list))


(defmacro seq-times-do (name body &rest commands)
  "Calls `seq-times' with arguments NAME, length and BODY (where
length is the number of COMMANDS) and then runs `seq-times'th
command from COMMANDS."
  (declare (indent 2))
  `(eval (nth (seq-times ,name ,(length commands) ,body) ',commands)))

;;}}}
;;{{{   Home/End

;; My home
(defvar my-home-end--point 0)
(defun my-home ()
   "Depending on how many times it was called moves the point to:
once - beginning of line; twice - indent;
three times - beginning of buffer; four times - back to where it was."
   (interactive)
   (seq-times-do nil (setq my-home-end--point (point))
     (beginning-of-line)
     (back-to-indentation)
     (goto-char (point-min))
     (goto-char my-home-end--point)))

(global-set-key "\C-a"          'my-home)
(global-set-key [(home)]        'my-home)
(global-set-key [(kp-home)]     'my-home)
(global-set-key [(f27)]         'my-home)
(global-set-key "\e[1~"         'my-home)


;; My end
(defun my-end () "Go to end of line or buffer" (interactive)
  (seq-times-do nil (setq my-home-end--point (point))
    (if folding-mode (folding-end-of-line) (end-of-line))
    (forward-paragraph)
    (goto-char (point-max))
    (goto-char my-home-end--point)))

(global-set-key "\C-e"          'my-end)
(global-set-key [(end)]         'my-end)
(global-set-key [(kp-end)]      'my-end)
(global-set-key [(select)]      'my-end)
(global-set-key [(f33)]         'my-end)
(global-set-key "\e[4~"         'my-end)

;;}}}
;;{{{   Pager/Scrolling

;; Makes paging functions work the way god intended
;; http://www.docs.uu.se/~mic/emacs.html
;; pager.el was modified by my
(require 'pager)
(setq pager-goto-edge t)

(global-set-key "\ev"           'pager-page-up)     ; Page Up
(global-set-key [(prior)]       'pager-page-up)
(global-set-key [(f29)]         'pager-page-up)
(global-set-key "\C-v"          'pager-page-down)   ; Page Down
(global-set-key [(next)]        'pager-page-down)
(global-set-key [(f35)]         'pager-page-down)

(set-key-lambda [(meta up)]     (scroll-down 1))    ; Alt+Up
(set-key-lambda [(meta kp-8)]   (scroll-down 1))
(set-key-lambda "\M-p"          (scroll-down 1))
(set-key-lambda [(meta down)]   (scroll-up   1))    ; Alt+Dn
(set-key-lambda [(meta kp-2)]   (scroll-up   1))
(set-key-lambda "\M-n"          (scroll-up   1))

(global-set-key [(meta shift up)]   'pager-row-up)  ; Alt+Shift+Up
(global-set-key [(meta shift kp-8)] 'pager-row-up)
(global-set-key "\M-P"              'pager-row-up)
(global-set-key [(meta shift down)] 'pager-row-down); Alt+Shift+Down
(global-set-key [(meta shift kp-2)] 'pager-row-down)
(global-set-key "\M-N"              'pager-row-down)

;;}}}
;;{{{   Save with no blanks

;; Save with no trailing whitespaces
;; XXX there is a delete-trailing-whitespace function which might be
;; added to write-file-hooks.
(defun save-no-blanks (&optional arg) (interactive "P")
  (unless arg
    (save-excursion
      (save-restriction
        (widen)
        (goto-char 0) (perform-replace "[ \t]+$" "" nil t nil)
        (goto-char (point-max))
        (unless (>= (skip-chars-backward "\n") -2)
          (delete-region (1+ (point)) (point-max))))))
  (save-buffer))

(global-set-key "\C-x\C-s"      'save-no-blanks)

;;}}}
;;{{{   Misc

(unless window-system
  (global-set-key "\C-h"          'delete-backward-char))
(global-set-key [(backspace)]   'delete-backward-char)
(global-set-key [(delete)]      'delete-char)

;(global-set-key "\C-xg"         'goto-line)             ; C-x g  goto line
;Since 22.1 M-g M-g and M-g g are goto line
(global-set-key "\C-xp"         "\C-u-1\C-xo")          ; C-x p  prev win
(global-set-key "\C-xk"         'kill-this-buffer)      ; don't ask which
                                                        ; buffer to kill
(global-set-key "\C-cr"         'revert-buffer)         ; Reload buffer
(set-key-lambda "\C-x\C-b" (switch-to-buffer (other-buffer))) ; C-x C-b switch
(global-set-key [(control ";")] 'comment-dwim)          ; C-; comments

(require 'imenu)
(global-set-key [(shift mouse-3)] 'imenu)
(setq imenu-sort-function 'imenu--sort-by-name)


;; Centering
(defvar centerer--window-start nil)

(defun centerer ()
  "Repositions current line: once - middle, twice - top, three and
four times - `reposition-window', five times - bottom, six times -
where it was at the beginning.
   If performing some action doesn't really change position of the
window function skips to another step."
   (interactive)
   (let ((i 0) (old (window-start)))
     (while (and (<= (setq i (1+ i)) 6) (equal (window-start) old))
       (seq-times-do nil (setq centerer--window-start (window-start))
         (recenter)
         (recenter 0)
         (reposition-window)
         (reposition-window)
         (recenter -1)
         (set-window-start (selected-window) centerer--window-start)))))

(global-set-key "\C-l"     'centerer)


;;{{{     Tab - indent or rotate or complete

;; Rotate Text + indent-or-complete
;; v0.3 by Michal Nazarewicz <mina86@tlen.pl>
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
;; http://www.emacswiki.org/cgi-bin/wiki/RotateText

;; Definition of words
(defvar rotate-text-rotations
  '(("mina86" "mina86@tlen.pl" "mina86@mina86.com" "http://mina86.com/")
    ("max" "min")
    ("north" "east" "south" "west")
    ("left" "top" "right" "bottom")
    ("red" "orange" "yellow" "green" "blue" "indigo" "violet"))
  "List of lists of words to rotate between.")


;; Rotates text
(defun rotate-text (text &optional rotations)
  "Rotates given string, ie. find string which follows given
string in ROTATIONS or nil if there is no such string.  If
ROTATION is nil `rotate-text-rotations' is used."
  (rotate-text--in text (or rotations rotate-text-rotations)))

;; Internal rotates text
(defun rotate-text--in (text rotations)
  "Similar to `rotate-text' but if ROTATIONS is nil returns nil."
  (and rotations
       (or (rotate-text--in-list text (car rotations))
           (rotate-text--in      text (cdr rotations)))))

;; Internal rotates text in list
(defun rotate-text--in-list (text list)
  "Searches for TEXT in LIST and returns string which is follows
it (or the first string in the list if TEXT is the last one).  If
string is not found on the list returns nil."
  (let ((l list))
    (while (and l (not (string-equal text (car l))))
      (setq l (cdr l)))
    (and l (or (cadr l) (car list)))))


;; Roatetes text in buffer
(defun rotate-region (&optional beg end)
  "Rotates string in buffer between BEG and END.  If string was
not found in `rotate-text-rotations' returns nil otherwise t.  If
BEG is nil either `region-beginning' (if `transient-mark-mode'
and `mark-active') or begining of word is used as the default.
If END is nil either `region-end' or end of word is used as the
default.  If function was called interactivly and mark was active
it lets it active."

  (save-excursion
    (setq beg
          (or beg
              (and transient-mark-mode mark-active (region-beginning))
              (progn (or (looking-at "\\<") (forward-word -1)) (point))))
    (setq end
          (or end
              (and transient-mark-mode mark-active (region-end))
              (progn (or (looking-at "\\>") (forward-word  1)) (point)))))

  (let ((do-region (and (interactive-p) transient-mark-mode mark-active))
        (str (rotate-text (buffer-substring beg end))))
    (when str
      (delete-region beg end)
      (goto-char beg)
      (insert str)
      (setq deactivate-mark (not do-region))
      t)))

;; hippie-expand try function
(defvar try-rotate-string--rotations)
(defvar try-rotate-string--num)
(defvar try-rotate-string--beg)
(defvar try-rotate-string--text)

(defun try-rotate-string (old)
  "Try to rotates text.  The argument OLD has to be nil the first
call of this function, and t for subsequent calls (for further
possible completions of the same string).  It returns t if a new
completion is found, nil otherwise.

This function can be added to `hippie-expand-try-functions-list'
or used interactivly.  To do the former use:

  (setq hippie-expand-try-functions-list
        (append (list 'try-rotate-string) hippie-expand-try-functions-list))"
  (interactive (list (eq this-command last-command)))
  (if old
      (when (>= (setq try-rotate-string--num (1+ try-rotate-string--num))
                (length (car try-rotate-string--rotations)))
        (setq try-rotate-string--rotations (cdr try-rotate-string--rotations)
              try-rotate-string--num       0))
    (setq try-rotate-string--rotations rotate-text-rotations
          try-rotate-string--num       1
          try-rotate-string--beg (save-excursion (forward-word -1) (point))
          try-rotate-string--text
          (buffer-substring try-rotate-string--beg (point))))

  (let ((text (buffer-substring try-rotate-string--beg (point)))
        replace ret)
    (while (and (not replace) try-rotate-string--rotations)
      (unless (setq replace (rotate-text--in-list
                             text (car try-rotate-string--rotations)))
        (setq try-rotate-string--rotations (cdr try-rotate-string--rotations)
              try-rotate-string--num       0
              text                         try-rotate-string--text)))

    (when (or replace old)
      (delete-region try-rotate-string--beg (point))
      (goto-char try-rotate-string--beg)
      (insert (or replace try-rotate-string--text)))
    replace))

(setq hippie-expand-try-functions-list
      '(try-rotate-string
;        try-expand-all-abbrevs
;        try-expand-list
;        try-expand-line
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol)
      hippie-expand-verbose nil)


;; Indent or complete
(defvar indent-or-complete-complete-function 'hippie-expand
  "Function to complete the word when using `indent-or-complete'
It is called with one argument - nil")

(defvar indent-or-complete--last-was-complete nil)

(defun indent-or-complete ()
  "Complete if point is at end of a word, otherwise indent line.
Uses `indent-or-complete-complete-function' function when completing
and `indent-for-tab-command' when indenting"
  (interactive)
  (if (set 'indent-or-complete--last-was-complete
           (or (looking-at "\\>")
               (and (eq last-command this-command)
                    indent-or-complete--last-was-complete)))
      (funcall indent-or-complete-complete-function nil)
    (indent-for-tab-command)))

;(global-set-key "\t"    'indent-or-complete)
;(global-set-key [(tab)] 'indent-or-complete)
(global-set-key "\M-/" 'hippie-expand)
(add-hook 'find-file-hooks (function (lambda ()
  (local-set-key [(tab)] 'indent-or-complete))))
(save-current-buffer
  (set-buffer "*scratch*")
  (local-set-key [(tab)] 'indent-or-complete))

;;}}}

;; Alt+q - Filling
(defun fill-paragraph-or-region (&optional arg)
  "Runs `fill-region' if `mark-active', `fill-paragraph' otherwise."
  (interactive (progn (barf-if-buffer-read-only)
                      (list (if current-prefix-arg 'full))))
  (if (and mark-active transient-mark-mode)
      (fill-region (region-beginning) (region-end) arg)
    (fill-paragraph arg))
  (setq deactivate-mark nil))

(defun my-fill () "" (interactive)
   (fill-paragraph-or-region (seq-times-nth () () left full right center)))

(global-set-key "\M-q"          'my-fill)

;; Alt+Q - Unfill
(defun th-unfill-paragraph-or-region ()
  "Do the opposite of `fill-paragraph-or-region'; stuff all lines
in the current paragraph into a single long line."
  (interactive)
  (let ((fill-column most-positive-fixnum))
    (if (and mark-active transient-mark-mode)
        (fill-region (region-beginning) (region-end) nil)
      (fill-paragraph nil)))
  (setq deactivate-mark nil))

(global-set-key "\M-Q"          'th-unfill-paragraph-or-region)


;; Do not break line after single character when filling
(defun fill-single-char-nobreak-p ()
  "Don't break line after a single character."
  (save-excursion
    (skip-chars-backward " \t")
    (backward-char 2)
    (looking-at "[[:space:]][a-zA-Z]")))

(add-to-list 'fill-nobreak-predicate 'fill-single-char-nobreak-p)


;; Jump
(require 'ffap)
(defun my-jump () "Jump to the thing at point." (interactive)
  (let ((thing (ffap-guesser))) (if thing (ffap thing)) t))

(global-set-key [(control return)] 'my-jump)
(global-set-key [(control shift mouse-1)] 'ffap-at-mouse)
(global-set-key "\C-x\C-f"      'ffap)


;; Make l behave as it should in help-mode
;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(add-hook 'help-mode-hook
          (function (lambda () (define-key help-mode-map "l" 'help-go-back))))

;; Copy to X-clipboard on C-x C-c
(defun x-set-clipboard-content-from-selection (begin end)
  "Sets X clipboard content to selected text."
  (interactive "r")
  (let ((x-select-enable-clipboard t))
    (x-select-text (buffer-substring begin end))))

(global-set-key "\C-xc"        'x-set-clipboard-content-from-selection)

;;}}}
;;{{{   Fkeys

;;{{{     Key sequences

(global-set-key "\eOP"       [(f1)])
(global-set-key "\e[[A"      [(f1)])
(global-set-key "\eOQ"       [(f2)])
(global-set-key "\e[[B"      [(f2)])
(global-set-key "\eOR"       [(f3)])
(global-set-key "\e[[C"      [(f3)])
(global-set-key "\eOS"       [(f4)])
(global-set-key "\e[[D"      [(f4)])
(global-set-key "\e[15~"     [(f5)])
(global-set-key "\e[[E"      [(f5)])
(global-set-key "\e[17~"     [(f6)])
(global-set-key "\e[18~"     [(f7)])
(global-set-key "\e[19~"     [(f8)])
(global-set-key "\e[20~"     [(f9)])
(global-set-key "\e[21~"     [(f10)])
(global-set-key "\e[23~"     [(f11)])
(global-set-key "\e[24~"     [(f12)])
(global-set-key "\eO5P"      [(control f1)])
(global-set-key "\eO5Q"      [(control f2)])
(global-set-key "\eO5R"      [(control f3)])
(global-set-key "\eO5S"      [(control f4)])
(global-set-key "\e[15;5~"   [(control f5)])
(global-set-key "\e[17;5~"   [(control f6)])
(global-set-key "\e[18;5~"   [(control f7)])
(global-set-key "\e[19;5~"   [(control f8)])
(global-set-key "\e[20;5~"   [(control f9)])
(global-set-key "\e[21;5~"   [(control f10)])
(global-set-key "\e[23;5~"   [(control f11)])
(global-set-key "\e[24;5~"   [(control f12)])
(global-set-key "\eO6P"      [(control shift f1)])
(global-set-key "\eO6Q"      [(control shift f2)])
(global-set-key "\eO6R"      [(control shift f3)])
(global-set-key "\eO6S"      [(control shift f4)])
(global-set-key "\e[15;6~"   [(control shift f5)])
(global-set-key "\e[17;6~"   [(control shift f6)])
(global-set-key "\e[18;6~"   [(control shift f7)])
(global-set-key "\e[19;6~"   [(control shift f8)])
(global-set-key "\e[20;6~"   [(control shift f9)])
(global-set-key "\e[21;6~"   [(control shift f10)])
(global-set-key "\e[23;6~"   [(control shift f11)])
(global-set-key "\e[24;6~"   [(control shift f12)])
(global-set-key "\eO3P"      [(meta f1)])
(global-set-key "\eO3Q"      [(meta f2)])
(global-set-key "\eO3R"      [(meta f3)])
(global-set-key "\eO3S"      [(meta f4)])
(global-set-key "\e[15;3~"   [(meta f5)])
(global-set-key "\e[17;3~"   [(meta f6)])
(global-set-key "\e[18;3~"   [(meta f7)])
(global-set-key "\e[19;3~"   [(meta f8)])
(global-set-key "\e[20;3~"   [(meta f9)])
(global-set-key "\e[21;3~"   [(meta f10)])
(global-set-key "\e[23;3~"   [(meta f11)])
(global-set-key "\e[24;3~"   [(meta f12)])
(global-set-key "\eO4P"      [(meta shift f1)])
(global-set-key "\eO4Q"      [(meta shift f2)])
(global-set-key "\eO4R"      [(meta shift f3)])
(global-set-key "\eO4S"      [(meta shift f4)])
(global-set-key "\e[15;4~"   [(meta shift f5)])
(global-set-key "\e[17;4~"   [(meta shift f6)])
(global-set-key "\e[18;4~"   [(meta shift f7)])
(global-set-key "\e[19;4~"   [(meta shift f8)])
(global-set-key "\e[20;4~"   [(meta shift f9)])
(global-set-key "\e[21;4~"   [(meta shift f10)])
(global-set-key "\e[23;4~"   [(meta shift f11)])
(global-set-key "\e[24;4~"   [(meta shift f12)])
(global-set-key "\eO2P"      [(shift f1)])
(global-set-key "\e[23~"     [(shift f1)])
(global-set-key "\eO2Q"      [(shift f2)])
(global-set-key "\e[24~"     [(shift f2)])
(global-set-key "\eO2R"      [(shift f3)])
(global-set-key "\e[25~"     [(shift f3)])
(global-set-key "\eO2S"      [(shift f4)])
(global-set-key "\e[26~"     [(shift f4)])
(global-set-key "\e[15;2~"   [(shift f5)])
(global-set-key "\e[28~"     [(shift f5)])
(global-set-key "\e[17;2~"   [(shift f6)])
(global-set-key "\e[29~"     [(shift f6)])
(global-set-key "\e[18;2~"   [(shift f7)])
(global-set-key "\e[31~"     [(shift f7)])
(global-set-key "\e[19;2~"   [(shift f8)])
(global-set-key "\e[32~"     [(shift f8)])
(global-set-key "\e[20;2~"   [(shift f9)])
(global-set-key "\e[33~"     [(shift f9)])
(global-set-key "\e[21;2~"   [(shift f10)])
(global-set-key "\e[34~"     [(shift f10)])
(global-set-key "\e[23;2~"   [(shift f11)])
(global-set-key "\e[24;2~"   [(shift f12)])

;;}}}
;;{{{     F1 - Help

(defun my-help ()
  "If function given tries to `describe-function' otherwise uses
`manual-entry' to display manpage of a `current-word'."
  (interactive)
   (let ((fn (function-called-at-point)))
     (if fn
         (describe-function fn)
       (manual-entry (current-word)))))

(global-set-key [(f1)]      'my-help)

;;}}}
;;{{{     F2 - find configuration files

(defmacro mn-kbd-find-file (file)
  `(function (lambda () (interactive) (find-file ,file))))

(global-set-key [(f2)]         (mn-kbd-find-file
                                (if (string-match "\\.elc$" user-init-file)
                                    (if (file-exists-p
                                         (substring user-init-file 0 -1))
                                        (substring user-init-file 0 -1)
                                        (substring user-init-file 0 -4))
                                  user-init-file)))
(global-set-key [(control f2)] (mn-kbd-find-file "~/.gnus/.gnus.el"))
(global-set-key [(meta f2)]    (mn-kbd-find-file custom-file))
(global-set-key [(shift f2)]   (mn-kbd-find-file "~/.bashrc"))

;;}}}
;;{{{     F5 - Gnus

;; http://www.emacswiki.org/cgi-bin/wiki/SwitchToGnus

(defun switch-to-gnus-or-get-new-news (&optional arg)
  "If already in Gnus group retrive new news otherwise, if Gnus
is running, switch to Gnus group buffer, otherwise start Gnus"
  (interactive "p")
  (cond
   ((eq major-mode 'gnus-group-mode)
    (and (fboundp 'gnus-group-get-new-news) (gnus-group-get-new-news)))
   ((and (boundp 'gnus-group-buffer) (fboundp 'gnus-alive-p) (gnus-alive-p))
    (switch-to-buffer (with-no-warnings gnus-group-buffer)))
   ((gnus))))

(global-set-key [(f5)]      'switch-to-gnus-or-get-new-news)
(set-key-lambda [(control f5)] (let ((b (current-buffer)))
                                 (switch-to-buffer (other-buffer))
                                 (bury-buffer b)))

;;}}}
;;{{{     F7 - spell checking

(require 'ispell)

;; my ispell-change-dictionary bugfix now commited to CVS
;; not need for it here

(defvar mn-spell-dictionaries '("polish" "british")
  "List of dictionaries to cycle through with `mn-spell-switch-dictionary'.")

(eval-after-load "ispell"
  (ispell-change-dictionary "polish" t))

(defun mn-spell (&optional lang start end)
  "If LANG is not-nil sets ispell dictionary to lang, then checks
region from START to END for spelling errors.  The default values
for START and END are `region-beginning' and `region-end' if
`transient-mark-mode' is on and `mark-active' or `point-min' and
`point-max' otherwise.

However, if START is nil, END is not and `region-beginning' falls
after END START will get value of `point-min'.  And the other way
around: if END is nil, START is not and `region-end' falls before
START END will get value of `point-max'.

If LANG is an empty string local dictionary is set to
nil (ie. the global dictionary is used).

If START >= END this function only sets the dictionary and
returns nil.  Otherwise it returns whatever `ispell-region'
returned."
  (interactive
   (list (completing-read
          "Use new dictionary (RET for current, SPC to complete): "
          (if (fboundp 'ispell-valid-dictionary-list)
              (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)))
  (if lang (ispell-change-dictionary (if (string= lang "") nil lang)))
  (cond
   ((not (and (boundp 'transient-mark-mode) transient-mark-mode
              (boundp 'mark-active) mark-active))
    (if (not start) (setq start (point-min)))
    (if (not end)   (setq end   (point-max))))
   ((not (or start end)) (setq start (region-beginning) end (region-end)))
   ((not start) (setq start (min (region-beginning) end  )))
   ((not end  ) (setq end   (max (region-end)       start))))
  (if (< start end) (ispell-region start end)))

(defun mn-spell-switch-dictionary (&optional arg)
  "Switches dictionary to the next dictionary from `mn-spell-dictionaries'.
With a prefix arg sets global dictionary."
  (interactive "P")
  (ispell-change-dictionary
   (let ((dic (or (and (not arg) ispell-local-dictionary) ispell-dictionary))
         (list mn-spell-dictionaries))
     (while (and list (not (string= (car list) dic))) (setq list (cdr list)))
     (or (cadr list) (car mn-spell-dictionaries)))
   arg))


(set-key-lambda [(f7)]         (mn-spell))
(set-key-lambda [(control f7)] (mn-spell nil (point)))

(global-set-key [(meta f7)]    'mn-spell-switch-dictionary)

;;}}}
;;{{{     F8 - Keyboard macros

(global-set-key [(f8)]         'kmacro-end-or-call-macro)
(global-set-key [(control f8)] 'kmacro-start-macro-or-insert-counter)
; Note also that as of EMACS 22.1 those are bind to F4 and F3
; respectively; I like mine bindings more though

;;}}}
;;{{{     F9 - Compilation

(eval-when-compile
  (defconst -mn-compile-common
    " -Wall -Wextra -Wfloat-equal -Wshadow -Wwrite-strings -Wunreachable-code -Winline -Wdisabled-optimization -ggdb -O0"))

(defvar mn-compile-vars
  `((("CFLAGS"   ,(eval-when-compile (concat "-std=c99 -Werror-implicit-function-declaration" -mn-compile-common)))
     ("CXXFLAGS" ,(eval-when-compile (concat "-std=c++98" -mn-compile-common)))
     ("CPPFLAGS" "-Wall -pedantic -DMINA86")
     ("LDFLAGS"  nil))

    (("CFLAGS"   ,(eval-when-compile (concat "-std=c89 -Wpadded -Werror-implicit-function-declaration" -mn-compile-common)))
     ("CXXFLAGS" ,(eval-when-compile (concat "-std=c++98 -Wpadded" -mn-compile-common)))
     ("CPPFLAGS" "-Wall -pedantic -DMINA86")
     ("LDFLAGS"  nil)))

  "List of enviroment variables set by `mn-compile' priory to
compilation.  The car of the list is a list of default enviroment
variables to be set and cadr is a list is a list of alternative
enviroment variables.  Each list is a list of two element lists
which car is a enviroment variables name and cadr is value.")


(defun mn-compile (&optional alt recompile touch)
  "If alt is omited or nil sets CFLAGS, CXXFLAGS, CPPFLAGS and
LDFLAGS enviroment variables to `mn-cflags', `mn-cxxflags',
`mn-cppflags', `mn-ldflags' respectively.

If alt is non-nil (or when called interactive with any prefix
argument) sets CFLAGS, CXXFLAGS, CPPFLAGS and LDFLAGS enviroment
variables to `mn-alt-cflags', `mn-alt-cxxflags',
`mn-alt-cppflags', `mn-alt-ldflags' respectively.

Afterwards, if touch is non-nil marks buffer as modified.  Saves
buffer (`save-buffer') and executes `recompile' if recompile is
non-nill or `compile' otherwise."

  (interactive "P")
  (if touch (set-buffer-modified-p t))
  (save-buffer)
  (if (or (eq major-mode 'lisp-mode) (eq major-mode 'emacs-lisp-mode))
      (auto-byte-compile-file nil t)
    (let (v (vars (if alt (cadr mn-compile-vars) (car mn-compile-vars))))
      (while (set 'v (pop vars)) (setenv (car v) (cadr v))))
    (if recompile (recompile) (call-interactively 'compile))))


(global-set-key [(f9)]      'mn-compile)               ; F9    compile
(global-set-key [(control f9)]                         ; C-F9  recompile
                (function (lambda (a) (interactive "P") (mn-compile a t))))
(global-set-key [(meta f9)]                            ; M-F9  force alt comp.
                (function (lambda (a) (interactive "P") (mn-compile (not a) t t))))

;;}}}

;;}}}
;;{{{   ISearch mode

(add-hook 'isearch-mode-hook (lambda ()
 (define-key isearch-mode-map "\C-h"      'isearch-mode-help)
 (define-key isearch-mode-map "\C-t"      'isearch-toggle-regexp)
 (define-key isearch-mode-map "\C-c"      'isearch-toggle-case-fold)
 (define-key isearch-mode-map "\C-j"      'isearch-edit-string)
; (define-key isearch-mode-map "\C-h"      'isearch-del-char)
 (define-key isearch-mode-map [backspace] 'isearch-del-char)
))

;;}}}
;;{{{   Copy Without Selection

;; http://www.emacswiki.org/cgi-bin/wiki/CopyWithoutSelection

(defun copy-word (&optional arg)
  "Copy words at point"
  (interactive "P")
  (let ((beg (progn (if (looking-back "[a-zA-Z]" 1) (backward-word 1)) (point)))
        (end (progn (forward-word arg) (point))))
    (copy-region-as-kill beg end)))

(defun copy-line (&optional arg)
  "Save current line into Kill-Ring without mark the line "
  (interactive "P")
  (let ((beg (line-beginning-position))
        (end (line-end-position)))
    (copy-region-as-kill beg end)))

(defun copy-paragraph (&optional arg)
  "Copy paragraphes at point"
  (interactive "P")
  (let ((beg (progn (backward-paragraph 1) (point)))
        (end (progn (forward-paragraph arg) (point))))
    (copy-region-as-kill beg end)))

(global-set-key "\C-cw"         'copy-word)
(global-set-key "\C-cl"         'copy-line)
(global-set-key "\C-cp"         'copy-paragraph)

;;}}}

;;}}}
;;{{{ Syntax highlighting

;; Font lock
(require 'font-lock)
(global-font-lock-mode t)
(setq font-lock-verbose nil)          ;no messages

;; Let customize keep config there
(setq custom-file (expand-file-name "~/.emacs.d/custom"))
(if (file-exists-p custom-file) (load-file custom-file))
(if (boundp 'auto-byte-compile-files-list)
    (setq auto-byte-compile-files-list
          (cons custom-file auto-byte-compile-files-list)))


;; Other
(setq query-replace-highlight t)  ;highlight during query
(setq search-highlight t)         ;highlight incremental search
(show-paren-mode t)               ;show matching parenthesis.
(setq blink-matching-paren-distance nil) ;search for open-paren till point-min

;; Show blanks and FIXME
;; http://www.emacswiki.org/cgi-bin/wiki/EightyColumnRule

(custom-set-faces
 '(my-tab-face ((((class color))
   (:background "#555" :foreground "black" :underline t))) t)
 '(my-big-indent-face ((((class color))
   (:background "#755" :foreground "black" :underline t))) t)
 '(my-huge-indent-face ((((class color))
   (:background "#C55" :foreground "black" :underline t))) t)
 '(my-fixme-face ((((class color))
   (:background "red" :foreground "white" :weight bold))) t)
 )


(add-hook 'font-lock-mode-hook (function (lambda ()
  (unless (or (eq 'diff-mode major-mode) (eq 'script-mode major-mode))
    (font-lock-add-keywords nil
     '(("\t+" 0 'my-tab-face t)
       ("^\t\\{4,\\}" 0 'my-big-indent-face t)
       ("^\t\\{6,\\}" 0 'my-huge-indent-face t)
       ("\\<\\(FIXME:?\\|XXX\\)" 1 'my-fixme-face t)))))))

;;}}}
;;{{{ Misc small config

;;Save some space
(menu-bar-mode -1)                ;no menu bar
(setq use-dialog-box nil)         ;never use dialog boxes
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
(if (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
(when window-system
  (require 'fringe)
  (set-fringe-mode '(3 . 3)))     ;small fringe


;; Modeline
(setq line-number-mode t)         ;show line number in modeline
(setq column-number-mode t)       ;show column number in modeline

(setq mode-line-format
      '("%e"
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        mode-line-buffer-identification
        "  "
        mode-line-position
        vc-mode
        " "
        mode-line-modes
        (which-func-mode ("" which-func-format))
        (global-mode-string ("" global-mode-string))
        "%-")

      mode-line-position
      '(:eval (let* ((min (point-min)) (max (point-max))
                     (wide (and (= min 1) (= max (1+ (buffer-size))))))
                (concat
                 (if wide "(" "[")
                 (if column-number-mode "%2c, " "")
                 (if line-number-mode "%2l/" "")
                 (number-to-string (1+ (count-lines min max)))
                 (if wide ")" "]"))))

      mode-line-modes
      '("("
        (:propertize
         ("" mode-name mode-line-process minor-mode-alist)
         help-echo "mouse-1: major mode, mouse-2: major mode help, mouse-3: toggle minor modes"
         mouse-face mode-line-highlight
         local-map (keymap
                    (header-line keymap
                                 (down-mouse-3 . mode-line-mode-menu-1))
                    (mode-line keymap
                               (down-mouse-3 . mode-line-mode-menu-1)
                               (mouse-2 . describe-mode)
                               (down-mouse-1 . mouse-major-mode-menu))))
        ") "))
(if (string-match "^tuptus\\." system-name)
    (display-battery-mode 1))     ;show battery on my laptop
;(setq display-time-24hr-format t) ;show time in 24h format
;(setq display-time-interval 30)   ;update time & load avg every 30s
;(display-time-mode 1)             ;show time in modeline


;; Other
(define-key minibuffer-local-map "\C-c"  ; C-c clears minibuffer
  (lambda () (interactive) (delete-minibuffer-contents)))
(setq suggest-key-bindings 3)     ;suggestions for shortcut keys for 3 seconds
(setq frame-title-format "%b - Emacs") ;frame title format
(setq history-delete-duplicates t);don't show splash screen
(setq inhibit-splash-screen   t)  ;don't show splash screen
(setq inhibit-startup-buffer-menu t) ;don't show buffer menu when oppening
                                  ; many files               (EMACS 21.4+)
(setq sentence-end-double-space 1);sentance end with double space
(setq truncate-lines nil)         ;wrap lines
(fset 'yes-or-no-p 'y-or-n-p)     ;make yes/no be y/n
(setq require-final-newline t)    ;always end file with NL
(setq x-alt-keysym 'meta)         ;treat Alt as Meta even if real Meta found
(setq gc-cons-threshold 4000000)  ;bytes before garbage collection
(setq ange-ftp-try-passive-mode t);passive FTP
;(setq ange-ftp-ftp-program-name "pftp") ;passive FTP
(blink-cursor-mode nil)           ;do not blink cursor
;(setq mouse-autoselect-window nil)  ;focus follows mouse


;; Saving etc
(if (fboundp recentf-mode)
    (recentf-mode nil))           ;no recent files
(auto-compression-mode 1)         ;automatic compression
(setq make-backup-files nil)      ;no backup
;(global-auto-revert-mode 1)       ;automaticly reload buffer when changed
                                  ; it makes all folds unfload :(
                                  ; and what's worse - sux with ftp


;; Indention
(defun tab-stop-list (&optional width columns)
  "Returns list of all positive integers ordered rom smallest to
largest which are multiplications of WIDTH and are lower or equal
COLUMNS.  WIDTH defaults to `tab-width' and COLUMNS to 120."
  (if (not width) (setq width tab-width))
  (when (<= width (or columns 120))
    (let* (l (n (/ (or columns 120) width )))
      (while (> (setq l (cons (* n width) l) n (1- n)) 0)) l)))

(setq indent-tabs-mode t)         ;indent using tabs
(setq c-basic-offset 4)           ;4 char indent in cc-mode
(setq tab-width 4)                ;tab width
(setq tab-stop-list (eval-when-compile (tab-stop-list 4)))
;; One could add this to check if tab-width and c-basic-offset correspond
;(if (not (= 0 (% c-basic-offset tab-width)))
;    (warn "`tab-width' does not divide `c-basic-offset'"))


;; Regionsm selections and marks
(setq mouse-yank-at-point t)      ;mouse yank at point not at cursor   (X-win)
(setq kill-read-only-ok t)        ;be silent when killing text from RO buffer
(delete-selection-mode 1)         ;deleting region by typing or del (like Win)
(setq transient-mark-mode t)
(setq set-mark-command-repeat-pop t)


;; Scrolling/moving
(setq scroll-step 1)              ;scroll one line
;(setq scroll-preserve-screen-position t) ;keep point's position on screen
(setq hscroll-step 1)             ;scroll one column
(setq next-line-add-newlines nil) ;no new lines with down arrow key


;; Coding system
(set-keyboard-coding-system 'iso-8859-2)
(set-terminal-coding-system 'iso-8859-2)


;; Blink Scroll Lock LED instead of beep
(setq visible-bell nil)           ;no visual bell
(setq ring-bell-function (function (lambda ()
  (call-process-shell-command "xset led 3; xset -led 3" nil 0 nil))))


;; Each list element as new paragraph
;; http://www.emacswiki.org/cgi-bin/wiki/FillParagraph
(setq paragraph-start    " *\\([*+-]\\|\\([0-9]+\\|[a-zA-Z]\\)[.)]\\|$\\)"
      paragraph-separate "$")


;; GDB
(setq gdb-many-windows t
      gdb-show-main t
      gdb-use-separate-io-buffer nil)

;;}}}
;;{{{ Major Modes

;;{{{   C Default compile command

(eval-after-load "compile"
  (progn
    (defun cc-make-compile-command ()
      "Sets `compile-command' to \"make -k <file-name-no-ext>\"."
      (let ((fn buffer-file-name) p)
        (when fn
          (setq fn (file-name-nondirectory fn)
                p (string-match "\\.[^\\.]*$" fn 1))
          (set (make-local-variable 'compile-command)
               (concat "make -k " (substring fn 0 p))))))

    (add-hook 'c-common-mode-hook 'cc-make-compile-command)))

;;}}}
;;{{{   HTML Mode

;; Insert char or entity when pressed 2 times
;; http://www.emacswiki.org/cgi-bin/wiki/DoubleKeyBinding
;(defmacro rgb-insert-if-double (otherwise)
;  `(lambda (arg) (interactive "P")
;               (if (or arg (not (equal (preceding-char) last-command-char)))
;                   (self-insert-command (prefix-numeric-value arg))
;                 (backward-delete-char 1)
;                 (insert ,otherwise))))
;
;(eval-when-compile (require 'sgml-mode))
;(eval-after-load "sgml-mode"
;  (progn
;   (add-hook 'html-mode-hook (lambda ()
;     (define-key html-mode-map "<"  (rgb-insert-if-double "&lt;"))
;     (define-key html-mode-map ">"  (rgb-insert-if-double "&gt;"))
;     (define-key html-mode-map "&"  (rgb-insert-if-double "&amp;"))
;     (define-key html-mode-map "\"" (rgb-insert-if-double "&quot;"))))))

;;}}}
;;{{{   (La)TeX and nroff mode

;; Helper for tex-space
(defun my-tex-looking-back (regexp len)
  "Returns non-nil if text LEN chars backward matches REGEXP and
is at the beginning of line or preceded by white space."
  (save-excursion
    (backward-char len)
    (if (looking-at regexp)
        (or (looking-at "^")
            (progn (backward-char 1) (looking-at "[[:space:]~]"))))))

;; Insert '~' or '\ ' instead of ' ' in LaTeX when needed
;; Also removes '~' when 2nd space added
;; http://www.debianusers.pl/article.php?aid=39
(defun tex-space (arg) (interactive "P")
  (cond
   ((re-search-backward "\\~" (- (point) 1) t)
    (delete-char 1) (self-insert-command (prefix-numeric-value arg)))
   (arg (self-insert-command (prefix-numeric-value arg)))
   ((or (my-tex-looking-back "[a-z]" 1)
        (my-tex-looking-back "[a-z][a-z]" 2))
    (insert-char ?~ 1))
   ((or (my-tex-looking-back "\\(?:tj\\|np\\|ew\\|jw\\|in\\|wg\\)\\." 3)
        (my-tex-looking-back "\\(?:tzw\||tzn\\)\\." 4))
    (insert "\\ "))
   (t (self-insert-command 1))))

(eval-when-compile (require 'tex-mode))
(add-hook 'tex-mode-hook
          (function (lambda () (define-key tex-mode-map " " 'tex-space))))
(add-hook 'latex-mode-hook
          (function (lambda () (define-key tex-mode-map " " 'tex-space))))


;; Insert '\ ' instead of ' ' in nroff when needed
;; Also removes '\' when 2nd space added
(defun nroff-space (arg) (interactive "p")
  (cond
   ((re-search-backward "\\\\ " (- (point) 2) t)
    (delete-char 1) (forward-char) (self-insert-command arg))
   ((> arg 1) (self-insert-command arg))
   ((or (my-tex-looking-back "[a-z]" 1)
        (my-tex-looking-back "[a-z][a-z]" 2))
;        (my-tex-search-back "do\\|na\\|od\\|po\\|za\\|we\\|to\\|co" 2))
    (insert-char ?\\ 1) (self-insert-command 1))
   (t (self-insert-command 1))))

(eval-when-compile (require 'nroff-mode))

(add-hook 'nroff-mode-hook
          (function (lambda () (define-key nroff-mode-map " " 'nroff-space))))

;;}}}
;;{{{   Misc

;; Text mode
(add-hook 'text-mode-hook (function (lambda ()
    (auto-fill-mode t)
    (setq tab-width 8)
    (setq tab-stop-list
    (set (make-local-variable 'tab-stop-list)
         (eval-when-compile (tab-stop-list 8)))))))


;; Assembler mode
(add-hook 'asm-mode-hook (function (lambda ()
    (set-variable 'tab-width 8)
    (set-variable 'tab-stop-list (tab-stop-list 16))
    (set-variable 'comment-column 40))))


;; PHP mode
;; http://sourceforge.net/projects/php-mode
(autoload 'php-mode "php-mode" "PHP editing mode" t)
(add-to-list 'auto-mode-alist '("\\.php\\'" . php-mode))


;; JavaScript mode
(add-to-list 'auto-mode-alist '("\\.js\\'" . c-mode))


;; Shell mode
;; This prevents shell commands from being echoed
(eval-when-compile (require 'shell))
(add-hook 'comint-mode-hook (function (lambda ()
  (setq comint-process-echoes t))))


;; Lisp/Scheme mode
;; No tabs!
(add-hook 'emacs-lisp-mode-hook (lambda () (setq indent-tabs-mode ())))
(add-hook 'lisp-mode-hook       (lambda () (setq indent-tabs-mode ())))
(add-hook 'scheme-mode-hook     (lambda () (setq indent-tabs-mode ())))


;; FVWM mode
;; http://groups.google.fr/groups?threadm=mailman.2630.1083314129.1061.help-gnu-emacs%40gnu.org
(autoload 'fvwm-mode "fvwm-mode" "Mode fore editing fvwm's config files" t)
(add-to-list 'auto-mode-alist '("\\.fv\\(wm2?\\(rc\\)?\\)?$" . fvwm-mode))


;; Bison mode
(autoload 'bison-mode "bison-mode.el")
(add-to-list 'auto-mode-alist '("\\.y$" . bison-mode))
(setq bison-decl-type-column   8)
(setq bison-decl-token-column 16)


;; Flex
(autoload 'flex-mode "flex-mode")
(add-to-list 'auto-mode-alist '("\\.l$" . flex-mode))


;; Script mode
(autoload 'script-mode "script-mode" "Mode fore editing scripts" t)


;; LSL mode
(autoload 'lsl-mode "lsl-mode" "Load LSL mode." t)
(add-to-list 'auto-mode-alist '("\\.lsl$" . lsl-mode))
(add-hook 'lsl-mode-hook (function (lambda nil (setq indent-tabs-mode nil))))

;;}}}

;;}}}
;;{{{ Various features

;;{{{   HTMLize

;; http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el
(autoload 'htmlize-buffer "htmlize" "Convert buffer to HTML" t)
(autoload 'htmlize-region "htmlize" "Convert region to HTML" t)

;;}}}
;;{{{   Folding

(when (load "folding")
  (defconst folding-default-keys-function
    '(folding-bind-backward-compatible-keys))

  (define-key folding-mode-map "\C-cf"         'folding-toggle-show-hide)
  (define-key folding-mode-map [(control ?c) (return)] 'folding-shift-in)
  (define-key folding-mode-map [(control ?c) (delete)] 'folding-shift-out)
  (define-key folding-mode-map [(control ?c) (backspace)] 'folding-shift-out)
  (define-key folding-mode-map "\C-c\C-f"      'folding-open-buffer)
  (define-key folding-mode-map "\C-cF"         'folding-whole-buffer)
  (define-key folding-mode-map "\C-e"          'my-end)

  (folding-add-to-marks-list 'php-mode        "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'javascript-mode "// {{{" "// }}}" nil t)
  (folding-add-to-marks-list 'css-mode        "/* {{{" "/* }}}" " */" t)

  (folding-mode-add-find-file-hook))

;;}}}
;;{{{   Different cursor color depending on mode

;; http://www.emacswiki.org/cgi-bin/wiki/EmacsNiftyTricks
(defvar hcz-set-cursor-color-color "")
(defvar hcz-set-cursor-color-buffer "")
(defun hcz-set-cursor-color-according-to-mode ()
  "Change cursor color according to some minor modes."
  ;; set-cursor-color is somewhat costly, so we only call it when needed:
  (let ((color (cond (buffer-read-only "blue")
                     (overwrite-mode "red")
                     (t "yellow"))))
    (unless (and
             (string= color hcz-set-cursor-color-color)
             (string= (buffer-name) hcz-set-cursor-color-buffer))
      (set-cursor-color (setq hcz-set-cursor-color-color color))
      (setq hcz-set-cursor-color-buffer (buffer-name)))))

(add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)

;;}}}
;;{{{   wc

;; Based on http://www.emacswiki.org/cgi-bin/wiki/WordCount
(defun wc (&optional start end)
  "Prints number of lines, words and characters in region or whole buffer."
  (interactive)
  (let ((n 0)
        (start (if mark-active (region-beginning) (point-min)))
        (end (if mark-active (region-end) (point-max))))
    (save-excursion
      (goto-char start)
      (while (< (point) end) (if (forward-word 1) (setq n (1+ n)))))
    (message "%3d %3d %3d" (count-lines start end) n (- end start))))

;;}}}
;;{{{   Command Frequency mode

(require 'command-frequency)
(command-frequency-table-load)
(command-frequency-mode 1)
(command-frequency-autosave-mode 1)
(setq command-frequency-table-file "~/.emacs.d/frequencies")

;;}}}
;;{{{   Notes in *scratch*

;; Notes in *scratch*  v. 0.2
;; Copyright (c) 2006 by Michal Nazarewicz (mina86@mina86.com)
;; Released under GNU GPL

(defconst scratch-file (expand-file-name "~/.emacs.d/scratch")
  "File where content of *scratch* buffer will be read from and saved to.")
(defconst scratch-file-autosave (concat scratch-file ".autosave")
  "File where to autosave content of *scratch* buffer.")

(save-excursion
  (set-buffer (get-buffer-create "*scratch*"))
  (if (file-readable-p scratch-file)
      (if (and (file-readable-p scratch-file-autosave)
               (file-newer-than-file-p scratch-file-autosave scratch-file)
               (y-or-n-p "Recover scratch file? "))
          (insert-file-contents scratch-file-autosave nil nil nil t)
        (insert-file-contents scratch-file nil nil nil t)
        (set-buffer-modified-p nil)))
  (auto-save-mode 1)
  (setq buffer-auto-save-file-name scratch-file-autosave)
;  (setq revert-buffer-function 'scratch-revert)
  (fundamental-mode))

(defun scratch-revert (ignore-auto noconfirm)
  (when (file-readable-p scratch-file)
    (insert-file-contents scratch-file nil nil nil t)
    (set-buffer-modified-p nil)))

(defun kill-scratch-buffer ()
  (not (when (string-equal (buffer-name (current-buffer)) "*scratch*")
         (delete-region (point-min) (point-max))
         (set-buffer-modified-p nil)
         (next-buffer)
         t)))

(defun kill-emacs-scratch-save ()
  (let ((buffer (get-buffer-create "*scratch*")))
    (if buffer
        (save-excursion
          (set-buffer buffer)
          (write-region nil nil scratch-file)
          (unless (string-equal scratch-file buffer-auto-save-file-name)
            (delete-auto-save-file-if-necessary t))))))

(add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
(add-hook 'kill-emacs-hook 'kill-emacs-scratch-save)

;;}}}

;; Start server
(server-start)

;;}}}
;;{{{ Fun stuff ;)

(defconst q   "This is EMACS not vi!  Use C-x C-c instead.")
(defconst w   "This is EMACS not vi!  Use C-x C-s instead.")
(defconst q!  "This is EMACS not vi!  Use C-x C-c instead.")
(defconst wq  "This is EMACS not vi!  Use C-x C-c instead.")
(defconst wq! "This is EMACS not vi!  Use C-x C-c instead.")

;;}}}

;; Clear messages
;; You may want to comment it out for debuging
(setq message-log-max nil)        ;disable messages
(kill-buffer "*Messages*")        ;kill buffer with messages

;(when (file-directory-p gnus-home-directory) (gnus))
